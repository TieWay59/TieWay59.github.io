{"pages":[],"posts":[{"title":"临时笔记栈","text":"事情总会一间一间···完成的。 线段树维护数组 左偏树 https://blog.csdn.net/wang3312362136/article/details/80615874 笛卡尔树 启发式合并https://baijiahao.baidu.com/s?id=1613444794783555531&amp;wfr=spider&amp;for=pc Min_25 筛重新学习笔记https://memset0.cn/min_25 划分树， 主席树， 二位线段树， 左偏树 zkw线段树https://blog.csdn.net/keshuqi/article/details/52205884 吉司机线段树https://blog.csdn.net/di4CoveRy/article/details/54582128 KD树https://www.cnblogs.com/earendil/p/8135074.html https://www.cnblogs.com/earendil/p/8135074.html https://blog.csdn.net/zjx_adstu/article/details/53366546 https://www.luogu.org/problem/P4357 1 到 N 的排列，最长上升子序列（LIS）长度的期望是多少？https://www.zhihu.com/question/266958886/answer/317982906 树形背包 书上做依赖背包","link":"/2019/08/08/Misc/临时笔记栈/"},{"title":"Hexo+ICARUS 使用指南与文章模板","text":"小白入门 文件头以这篇文章为例，可以知道这每个文件开头面要写这些东西，设置了文件的各种信息。 最好是从bash里hexo new “xxx” 在名字之前可以带一个模板的名字（不用引号），也可以预先准备一些写好的东西，挺方便的。 12345678910---title: Hexo+ICARUS 使用指南与文章模板date: 2019-08-05 22:05:36tags: //无顺序，单一层级- blogsite- postguidetoc: true //启用章内索引categories: //有顺序，体现分类层级- misc --- 插入图片简单的做法是安装插件， 1npm install hexo-asset-image --save Make sure post_asset_folder: true in your _config.yml. Just use ![logo](logo.jpg) to insert logo.jpg. 但是 截止目前，这个插件的作者好像没有更新npm的包，所以github上的代码是最新的，我是直接下载放入.\\node_modules路径里，才真正生效。 折叠文章你会发现本样式中的文章默认在主页是不折叠的，需要在文章里写： 1&lt;!--more--&gt; 这样的作用代表之后的内容都会在外部折叠隐藏。（营造一种神奇的摘要的错觉） 也可以加入模板，省心省事。 章头图片也就是缩略图，主要看这里 https://blog.zhangruipeng.me/hexo-theme-icarus/Configuration/Posts/adding-a-thumbnail-to-your-article/ 设置好以后，文件头里加入thumbnail: ···就可以了。 TBCD···","link":"/2019/08/05/Misc/Hexo-ICARUS-使用指南与文章模板/"},{"title":"2019.8.8 牛客多校第七场","text":"2019牛客暑期多校训练营（第七场） 题号 标题 通过率 dsc stt A String 691/3864 暴力/想法 √- B Irreducible Polynomial 792/2431 结论 √- C Governing sand 520/2702 线段树 √- D Number 985/1499 签到 √- E Find the median 138/1261 F Energy stones 20/149 G Make Shan Happy 3/29 H Pair 143/343 数位DP I Chessboard 34/129 J A+B problem 1061/1919 签到 √- K Function 17/64 ○ 代表赛后补题 √+ 代表赛内我通过的 √- 代表赛内不是我做的 √-○代表赛内不是我做的，补了 A (520/3277) B (682/2135) C (348/1829) D (947/1447) E (74/842) F (14/97) F (14/97) G (2/27) H (83/204) I (16/71) J (997/1793) K (7/40) 01:56:17(-8) 00:36:55 03:14:32 00:09:09 00:04:42 A题意感觉可以变成一个很难得题。 虽然说暴力就可以，但我不是很懂欸= =。 B题意是给一个多项式，判断多项式是否还能因式分解。 有一个结论是，少于三项肯定不行，多于三项必定可以。 判断一下三项得情况就好了（对于n=2）； C给n种树，每种树有高度，花费，数量三个属性，现在要求砍掉一些树，使得剩下得树最高的严格大于剩余树的总数的一半。求最小花费。 注意，允许多种树的高度相等。 虽然不是我做的，但是和队友大概的思路是这样的，从高到低枚举高度，这个高度作为最后剩下树的最高高度，每次删掉比这个高度高的树的总花费，再去查询余下的树还需要删去的前m棵最小的花费和。 这个可以用线段树维护一下，但是还没想通。 D给了n和p, 需要输出一个数，刚好有n位数而且整除p. 思路是直接再p后面填0即可。","link":"/2019/08/08/CP/Logs/2019-8-8-牛客多校第七场/"},{"title":"2019.8.6 队内训练","text":"UFBA Practice Session for Brazilian ICPC Regionals - 2018 # Name AC Dsc Stt A Multiset Machine x9 B Color Changing Sofa x140 签到 √- C Renan and Cirque du Soleil x89 推公式 √- D Carnival x25 E Hat-Xor x135 想法/读题 √+ F Renanzinho and His Toys x70 二分/dp/尺取 ○ G Barra Lighthouse x31 H All-In x48 I Colonial Mansions x101 线段树 √- J Soteros x58 K Rei do Cangaço x133 模拟 √- L Code Name Hummingbird x3 M Sorting Machine x41 ○ 代表赛后补题 √+ 代表赛内我通过的 √- 代表赛内不是我做的 √-○代表赛内不是我做的，补了 # = Pen A B C D E F G H I J K L M 1 (64) 5 657 +1 00:29 +2 02:18 + 02:06 -2 -1 +1 03:31 + 01:13","link":"/2019/08/07/CP/Logs/2019-8-6-队内训练/"},{"title":"hdu-6638 线段树 最大子段和","text":"题意给你n个坐标，每个坐标有权值（可正可负），目标是找一个平行于坐标轴矩阵，使得矩阵内的取值求和最大，输出最大值。这个矩阵的坐标可以是非整数的，但是输入是整数的，暗示单个点也是可以被框出来的。 思路比较容易想到的是，先离散化坐标，求一个最大子矩阵好像就可以了。 但是想想这个复杂度，对于一个二维数组求最大子矩阵的话，复杂度是$O(n^3)$的，这里2000个点可以对角线排列，那么二维数组的大小就是2000x2000的，三次的复杂度其实不可接受。 然后就去想，这个题里的点其实比较稀疏，只占二维平面里的一点点空间，而一般的做法第三维是需要一次$O(n)$的遍历来做区间最大子段和的，那么在这个问题里我们可以想办法在更少的时间算出最大子段和，并且避开遍历n次的时间。 做法就是用线段树来维护最大子段和，对于那些落在边界内部的点，可以预处理排序所有的点，这样可尺取地逐步放入边界里的点，放完了就可以用线段树得到当前的答案，然后继续移动边界，把下面的点加入线段树，继续计算答案并更新。 这个线段树的设计可以是单点更新$O(log(n))$，并$O(1)$询问的。总体复杂度$O(n^2log(n))$ 数组说明1234ll sum[TreeSize]; //表示区间和ll lft[TreeSize]; //表示当前区间左边开始连续的最大子段和ll rht[TreeSize]; //表示当前区间右边开始连续的最大子段和ll ans[TreeSize]; //表示当前区间的答案（最大字段和） Pro.ID Exe.Time Exe.Memory Language Author 6638 2308MS 1760K G++ tieway59 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161#include &lt;bits/stdc++.h&gt;#define _debug(x) cerr&lt;&lt; #x &lt;&lt; \" = \"&lt;&lt;x &lt;&lt;endlusing namespace std;typedef long long ll;const ll INF = 0x3f3f3f3f;const ll LINF = 0x3f3f3f3f3f3f3f3f;const int MAXN = 4000 + 59;const int TreeSize = MAXN &lt;&lt; 2;struct SegTree {#define lson (oo&lt;&lt;1)#define rson (oo&lt;&lt;1|1) int n; ll sum[TreeSize]; ll lft[TreeSize]; ll rht[TreeSize]; ll ans[TreeSize]; void init(int _n) { this-&gt;n = _n; build(1, 1, _n); } void build(int oo, int l, int r) { if (l == r) { sum[oo] = lft[oo] = rht[oo] = ans[oo] = 0; return; } int m = (l + r) &gt;&gt; 1; build(lson, l, m); build(rson, m + 1, r); sum[oo] = lft[oo] = rht[oo] = ans[oo] = 0; } void update(int oo, int l, int r, int pos, ll val) { if (l == r &amp;&amp; r == pos) { sum[oo] += val;//+val? rht[oo] = max(0ll, sum[oo]); lft[oo] = max(0ll, sum[oo]); ans[oo] = max(0ll, sum[oo]); return; } int m = (l + r) &gt;&gt; 1; if (pos &lt;= m) update(lson, l, m, pos, val); else update(rson, m + 1, r, pos, val); lft[oo] = lft[lson]; rht[oo] = rht[rson]; sum[oo] = sum[lson] + sum[rson]; ans[oo] = max(ans[lson], ans[rson]); ans[oo] = max(ans[oo], rht[lson] + lft[rson]); lft[oo] = max(lft[oo], sum[lson] + lft[rson]); rht[oo] = max(rht[oo], rht[lson] + sum[rson]); if (lft[lson] == sum[lson]) ans[oo] = max(ans[oo], lft[lson] + lft[rson]); if (rht[rson] == sum[rson]) ans[oo] = max(ans[oo], rht[lson] + rht[rson]); } void update(int pos, ll val) { update(1, 1, n, pos, val); } ll query() { return ans[1]; }};SegTree tree;struct point { int x, y, v;} p[MAXN];int dsc[MAXN], dtot;void initDsc() { sort(dsc, dsc + dtot); dtot = unique(dsc, dsc + dtot) - dsc;}int getDsc(const int &amp;val) { return lower_bound(dsc, dsc + dtot, val) - dsc + 1;}int n;ll ans;int Kase;int xmax, ymax;int main() { ios_base::sync_with_stdio(0); cin.tie(0); cin &gt;&gt; Kase; while (Kase--) { ans = 0; dtot = 0; xmax = ymax = 0; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) { cin &gt;&gt; p[i].x &gt;&gt; p[i].y &gt;&gt; p[i].v; dsc[dtot++] = p[i].x; dsc[dtot++] = p[i].y; } initDsc(); for (int i = 1; i &lt;= n; ++i) { p[i].x = getDsc(p[i].x); p[i].y = getDsc(p[i].y); xmax = max(xmax, p[i].x); ymax = max(ymax, p[i].y); } sort(p + 1, p + 1 + n, [](const point &amp;a, const point &amp;b) { if (a.x == b.x)return a.y &lt; b.y; return a.x &lt; b.x; }); for (int l = 1; l &lt;= n; l++) { tree.init(ymax); for (int r = l; r &lt;= n; r++) { tree.update(p[r].y, p[r].v); if (p[r].x != p[r + 1].x) { ans = max(ans, tree.query()); } } while (p[l].x == p[l + 1].x)l++; } cout &lt;&lt; ans &lt;&lt; '\\n'; } return 0;}/*241 1 502 1 501 2 502 2 -5002-1 1 5-1 1 1 */","link":"/2019/08/08/CP/Solutions/hdu-6638-线段树-最大子段和/"}],"tags":[{"name":"建站","slug":"建站","link":"/tags/建站/"},{"name":"线段树","slug":"线段树","link":"/tags/线段树/"},{"name":"hdu","slug":"hdu","link":"/tags/hdu/"}],"categories":[{"name":"misc","slug":"misc","link":"/categories/misc/"},{"name":"CP","slug":"CP","link":"/categories/CP/"},{"name":"Logs","slug":"CP/Logs","link":"/categories/CP/Logs/"},{"name":"Solutions","slug":"CP/Solutions","link":"/categories/CP/Solutions/"}]}