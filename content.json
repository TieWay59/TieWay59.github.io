{"pages":[],"posts":[{"title":"Hexo+ICARUS 使用指南与文章模板","text":"文件头以这篇文章为例，可以知道这每个文件开头面要写这些东西，设置了文件的各种信息。 最好是从bash里hexo new “xxx”这样新建比较好。 12345678910---title: Hexo+ICARUS 使用指南与文章模板date: 2019-08-05 22:05:36tags: - blogsite- postguidetoc: truecategories: - misc--- TBCD···","link":"/2019/08/05/Hexo-ICARUS-使用指南与文章模板/"},{"title":"Test","text":"index &gt; STL &gt; map 细致的介绍还是前人做的好，我自愧不如。 https://blog.csdn.net/fhb1922702569/article/details/80984774 https://blog.csdn.net/sevenjoin/article/details/81943864 关于比较 列几点我常忽视的细节： 用mp.insert()函数插入已有key的数据时，不能插入数据。而mp[key]引用可改写key对应的value。 map內部的实现自建一颗红黑树，这颗树具有对数据自动排序的功能。（面试可能也会见到相关的提问） 部分应用离散化单纯利用一一对应的特性。 打标记虽然说用 [] 很方便，但是如果就是二元的标记，还是巧用insert/erase/find/count 比较稳妥。（原因有待解释，可能打脸） 特殊二叉搜索树（类红黑树） ——“你其实有一棵随叫随到的红黑树。” 须知： map是有序容器。 mp.begin() 可访问第一个键值对（最值）。 mp[key] 修改某个key的权值，而且改完保持有序。 mp.insert() mp.erase() mp.find() 增删改查都有。 甚至还能自行 mp.lower_bound() mp.upper_bound() 默认lesser&lt;int&gt;升序，想要降序也可以（如果不是原生类型得另外写比较类）： 1map&lt;int, int, greater&lt;int&gt; &gt; cnts; 有了上面这些领悟，你这可以解决某些特定的情况： 比如有一群人，每个人的分数不同，找一下最高分的人有几个。 或者，要输出，第一/第二/第三的分数，和对应的人数。 如果嫌简单，再难一点，修改m次分数，每次修改就再求一次答案。 1e6的人数，1e9的分数，可有负分，修改/询问1e6。 可能以上这个题目比较拙劣，如果以后有更好的会再放进来。简单地说，充分利用key排序和修改方便的特性。","link":"/2019/08/05/Test/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/08/05/hello-world/"},{"title":"Test","text":"index &gt; STL &gt; map 细致的介绍还是前人做的好，我自愧不如。 https://blog.csdn.net/fhb1922702569/article/details/80984774 https://blog.csdn.net/sevenjoin/article/details/81943864 关于比较 列几点我常忽视的细节： 用mp.insert()函数插入已有key的数据时，不能插入数据。而mp[key]引用可改写key对应的value。 map內部的实现自建一颗红黑树，这颗树具有对数据自动排序的功能。（面试可能也会见到相关的提问） 部分应用离散化单纯利用一一对应的特性。 打标记虽然说用 [] 很方便，但是如果就是二元的标记，还是巧用insert/erase/find/count 比较稳妥。（原因有待解释，可能打脸） 特殊二叉搜索树（类红黑树） ——“你其实有一棵随叫随到的红黑树。” 须知： map是有序容器。 mp.begin() 可访问第一个键值对（最值）。 mp[key] 修改某个key的权值，而且改完保持有序。 mp.insert() mp.erase() mp.find() 增删改查都有。 甚至还能自行 mp.lower_bound() mp.upper_bound() 默认lesser&lt;int&gt;升序，想要降序也可以（如果不是原生类型得另外写比较类）： 1map&lt;int, int, greater&lt;int&gt; &gt; cnts; 有了上面这些领悟，你这可以解决某些特定的情况： 比如有一群人，每个人的分数不同，找一下最高分的人有几个。 或者，要输出，第一/第二/第三的分数，和对应的人数。 如果嫌简单，再难一点，修改m次分数，每次修改就再求一次答案。 1e6的人数，1e9的分数，可有负分，修改/询问1e6。 可能以上这个题目比较拙劣，如果以后有更好的会再放进来。简单地说，充分利用key排序和修改方便的特性。","link":"/2019/08/05/set/Test/"}],"tags":[{"name":"建站","slug":"建站","link":"/tags/建站/"},{"name":"testin","slug":"testin","link":"/tags/testin/"}],"categories":[{"name":"misc","slug":"misc","link":"/categories/misc/"},{"name":"set","slug":"set","link":"/categories/set/"}]}