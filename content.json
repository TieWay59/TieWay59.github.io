{"pages":[],"posts":[{"title":"2019.8.12 杭电多校第七场","text":"# name AC dsc stt 6646 A + B = C 23.67%(125/528) 想法/大数/字符串 6647 Bracket Sequences on Tree 18.60%(8/43) 6648 Cuber Occurrence 22.22%(2/9) 6649 Data Structure Problem 25.00%(3/12) 6650 Equation 11.11%(1/9) 6651 Final Exam 47.09%(421/894) 想法/结论 √+ 6652 Getting Your Money Back 16.82%(18/107) 6653 Halt Hater 30.09%(34/113) 6654 Intersection of Prisms 0.00%(0/6) 6655 Just Repeat 18.23%(128/702) 6656 Kejin Player 38.95%(201/516) 概率 √+ ○ 代表赛后补题 √+ 代表赛内我通过的 √- 代表赛内不是我做的 √-○代表赛内不是我做的，补了 Kejin Player很庆幸自己过了。第一次自己推出概率计算题。 问题是从i级升到i+1级有一个花费ai，但是有一个概率pi，代表成功率。如果失败了，就会掉到登记ri。 现在多次询问l到r等级的升级花费。 从i到i+1其实是一个几何概型，每次试验的成功率是pi，那么重复试验到第一次成功的期望可以知道是$\\frac{1}{pi} $这个问题可以去专门学一下几何概型。 可以说平均花了$\\frac{1}{pi} $次才升级，那么$\\frac{1}{pi}-1 $就是降级的次数，降级的次数再乘上从ri升到i的花费就是平均升级失败以后补救的花费，补救+ai就是从i升到i+1的花费。 计算出i到i+1的。","link":"/2019/08/12/2019-8-12-杭电多校第七场/"},{"title":"Github没计绿点的问题","text":"详细问题见：Github为什么没有记录你的Contributions 我的问题就是本地git的账号和github的不一样，在下面这个页面插入即可。https://github.com/settings/emails","link":"/2019/08/09/Misc/Github没计绿点的问题/"},{"title":"Hexo+ICARUS 使用指南与文章模板","text":"小白入门 文件头以这篇文章为例，可以知道这每个文件开头面要写这些东西，设置了文件的各种信息。 最好是从bash里hexo new “xxx” 在名字之前可以带一个模板的名字（不用引号），也可以预先准备一些写好的东西，挺方便的。 12345678910---title: Hexo+ICARUS 使用指南与文章模板date: 2019-08-05 22:05:36tags: //无顺序，单一层级- blogsite- postguidetoc: true //启用章内索引categories: //有顺序，体现分类层级- misc --- 插入图片简单的做法是安装插件， 1npm install hexo-asset-image --save Make sure post_asset_folder: true in your _config.yml. Just use ![logo](logo.jpg) to insert logo.jpg. 但是 截止目前，这个插件的作者好像没有更新npm的包，所以github上的代码是最新的，我是直接下载放入.\\node_modules路径里，才真正生效。 折叠文章你会发现本样式中的文章默认在主页是不折叠的，需要在文章里写： 1&lt;!--more--&gt; 这样的作用代表之后的内容都会在外部折叠隐藏。（营造一种神奇的摘要的错觉） 也可以加入模板，省心省事。 章头图片也就是缩略图，主要看这里 https://blog.zhangruipeng.me/hexo-theme-icarus/Configuration/Posts/adding-a-thumbnail-to-your-article/ 设置好以后，文件头里加入thumbnail: ···就可以了。 链接🔗写链接尽量带上协议，不然会被实别成路径。 TBCD···","link":"/2019/08/05/Misc/Hexo-ICARUS-使用指南与文章模板/"},{"title":"Qzone 相册照片链接测试","text":"特别鸣谢阿翔同学让我想到了这个问题。","link":"/2019/08/09/Misc/Qzone-相册照片链接测试/"},{"title":"临时笔记栈","text":"事情总会一件一件···完成的。 线段树维护数组 左偏树 https://blog.csdn.net/wang3312362136/article/details/80615874 笛卡尔树 启发式合并https://baijiahao.baidu.com/s?id=1613444794783555531&amp;wfr=spider&amp;for=pc Min_25 筛重新学习笔记https://memset0.cn/min_25 斐波那契堆 划分树， 主席树， 二位线段树， 左偏树 zkw线段树https://blog.csdn.net/keshuqi/article/details/52205884 吉司机线段树https://blog.csdn.net/di4CoveRy/article/details/54582128 KD树https://www.cnblogs.com/earendil/p/8135074.htmlhttps://www.cnblogs.com/earendil/p/8135074.htmlhttps://blog.csdn.net/zjx_adstu/article/details/53366546https://www.luogu.org/problem/P4357 1 到 N 的排列，最长上升子序列（LIS）长度的期望是多少？https://www.zhihu.com/question/266958886/answer/317982906 树形背包 书上做依赖背包","link":"/2019/08/08/Misc/临时笔记栈/"},{"title":"2019.8.8 牛客多校第七场","text":"2019牛客暑期多校训练营（第七场） 题号 标题 通过率 dsc stt A String 691/3864 暴力/想法 √- B Irreducible Polynomial 792/2431 结论 √- C Governing sand 520/2702 线段树 √- D Number 985/1499 签到 √- E Find the median 138/1261 F Energy stones 20/149 G Make Shan Happy 3/29 H Pair 143/343 数位DP I Chessboard 34/129 J A+B problem 1061/1919 签到 √- K Function 17/64 ○ 代表赛后补题 √+ 代表赛内我通过的 √- 代表赛内不是我做的 √-○代表赛内不是我做的，补了 A (520/3277) B (682/2135) C (348/1829) D (947/1447) E (74/842) F (14/97) F (14/97) G (2/27) H (83/204) I (16/71) J (997/1793) K (7/40) 01:56:17(-8) 00:36:55 03:14:32 00:09:09 00:04:42 A题意感觉可以变成一个很难得题。 虽然说暴力就可以，但我不是很懂欸= =。 B题意是给一个多项式，判断多项式是否还能因式分解。 有一个结论是，少于三项肯定不行，多于三项必定可以。 判断一下三项得情况就好了（对于n=2）； C给n种树，每种树有高度，花费，数量三个属性，现在要求砍掉一些树，使得剩下得树最高的严格大于剩余树的总数的一半。求最小花费。 注意，允许多种树的高度相等。 虽然不是我做的，但是和队友大概的思路是这样的，从高到低枚举高度，这个高度作为最后剩下树的最高高度，每次删掉比这个高度高的树的总花费，再去查询余下的树还需要删去的前m棵最小的花费和。 这个可以用线段树维护一下，但是还没想通。 D给了n和p, 需要输出一个数，刚好有n位数而且整除p. 思路是直接再p后面填0即可。","link":"/2019/08/08/CP/Logs/2019-8-8-牛客多校第七场/"},{"title":"2019.8.6 队内训练","text":"UFBA Practice Session for Brazilian ICPC Regionals - 2018 # Name AC Dsc Stt A Multiset Machine x9 B Color Changing Sofa x140 签到 √- C Renan and Cirque du Soleil x89 推公式 √- D Carnival x25 E Hat-Xor x135 想法/读题 √+ F Renanzinho and His Toys x70 二分/dp/尺取 ○ G Barra Lighthouse x31 H All-In x48 I Colonial Mansions x101 线段树 √- J Soteros x58 K Rei do Cangaço x133 模拟 √- L Code Name Hummingbird x3 M Sorting Machine x41 ○ 代表赛后补题 √+ 代表赛内我通过的 √- 代表赛内不是我做的 √-○代表赛内不是我做的，补了 # = Pen A B C D E F G H I J K L M 1 (64) 5 657 +1 00:29 +2 02:18 + 02:06 -2 -1 +1 03:31 + 01:13","link":"/2019/08/07/CP/Logs/2019-8-6-队内训练/"},{"title":"sweep line 扫描线略知略会","text":"做了一些有相同思路的题，先留个坑。 思路 🌎 2019/8/16 21:48:22我的理解是 对一些事件根据一定顺序排序然后for ​ ——辰巨如是说 待阅读https://codeforces.com/blog/entry/20377 https://blog.csdn.net/xianpingping/article/details/83032798 https://blog.csdn.net/sslz_fsy/article/details/82902644 例题与例程ZJNU 1426(弊校OJ，可能打不开) 12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;int n,cur,ans;map&lt;int, int&gt; cnt;int main() { ios_base::sync_with_stdio(0); cin.tie(0); cin &gt;&gt; n; for (int a, b, i = 1; i &lt;= n; i++) { cin &gt;&gt; a &gt;&gt; b; cnt[a - 1]++; cnt[b]--; } for (auto pi:cnt) { ans = max(ans, cur); cur += pi.second; } cout &lt;&lt; ans &lt;&lt; endl; return 0;} NCOJ 889D Symmetrical Painting2019牛客暑期多校训练营（第九场）J 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt; #define get0(x) get&lt;0&gt;(x)#define get1(x) get&lt;1&gt;(x)#define _debug(x) cerr&lt;&lt;#x&lt;&lt;\" = \"&lt;&lt;x&lt;&lt;endlusing namespace std;typedef long long ll;const int MAXN = 1e6 + 59;const ll MOD = 1e9 + 7; ll n, ans;vector&lt;tuple&lt;int, int&gt; &gt; pos; int main() { ios_base::sync_with_stdio(0); cin.tie(0); cin &gt;&gt; n; pos.emplace_back(0, 0); for (ll l, r, i = 1; i &lt;= n; i++) { cin &gt;&gt; l &gt;&gt; r; pos.emplace_back(l + l, 1); pos.emplace_back(l + r, -2); pos.emplace_back(r + r, 1); } sort(pos.begin(), pos.end()); ll cur = 0; ll del = 0; ll las = 0; for (auto &amp;p:pos) { cur += (get0(p) - las) * del; del += get1(p); las = get0(p); ans = max(ans, cur); } cout &lt;&lt; ans &lt;&lt; endl; return 0;} HDU 6627HDU 2019 Multi-University Training Contest 5 这题main函数里其实不复杂，但是分数可真是搞死我了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193#include &lt;bits/stdc++.h&gt;#define get0(x) get&lt;0&gt;(x)#define get1(x) get&lt;1&gt;(x)#define get2(x) get&lt;2&gt;(x)#define _debug(x) cerr&lt;&lt;#x&lt;&lt;\" = \"&lt;&lt;x&lt;&lt;endlusing namespace std;typedef long long ll;const int MAXN = 1e6 + 59;const ll MOD = 1e9 + 7;const ll INF = 1001;typedef struct frac { ll a, b; frac() : a(0), b(1) {} frac(ll _a) : a(_a), b(1) {} frac(ll _a, ll _b) : a(_a), b(_b) { if (a == 0) { this-&gt;b = 1; } if (b &lt; 0) { this-&gt;a = -_a; this-&gt;b = -_b; } ll g = __gcd(abs(a), abs(b)); this-&gt;a /= g; this-&gt;b /= g; } frac operator+(const frac &amp;rht) const { return frac(a * rht.b + b * rht.a, b * rht.b); } frac operator-(const frac &amp;rht) const { return frac(a * rht.b - b * rht.a, b * rht.b); } frac operator*(const frac &amp;rht) const { return frac(a * rht.a, b * rht.b); } frac operator/(const frac &amp;rht) const { return frac(a * rht.b, b * rht.a); } bool operator&lt;(const frac &amp;rht) const { return a * rht.b &lt; b * rht.a; } bool operator&lt;=(const frac &amp;rht) const { return a * rht.b &lt;= b * rht.a; } bool operator&gt;(const frac &amp;rht) const { return a * rht.b &gt; b * rht.a; } bool operator&gt;=(const frac &amp;rht) const { return a * rht.b &gt;= b * rht.a; } bool operator==(const frac &amp;rht) const { return a * rht.b == b * rht.a; } friend ostream &amp;operator&lt;&lt;(ostream &amp;out, frac &amp;T); void operator()(ll _a, ll _b) { *this = frac(_a, _b); }} fc;ostream &amp;operator&lt;&lt;(ostream &amp;out, fc &amp;T) { out &lt;&lt; T.a &lt;&lt; \"/\" &lt;&lt; T.b; return out;}// y1&lt;y2fc calc1(fc x1, fc y1, fc x2, fc y2, fc c) { fc dx = x2 - x1; fc dy = y2 - y1; fc dc = c - y1; return x1 + dc * dx / dy;}// y1&gt;y2fc calc2(fc x1, fc y1, fc x2, fc y2, fc c) { fc dx = x2 - x1; fc dy = y1 - y2; fc dc = c - y2; return x2 - dc * dx / dy;}ll n, kase, c;vector&lt;tuple&lt;fc, ll, ll&gt; &gt; pos;vector&lt;fc&gt; ans;int main() { ios_base::sync_with_stdio(0); cin.tie(0); cin &gt;&gt; kase; while (kase--) { ans.clear(); pos.clear(); cin &gt;&gt; n &gt;&gt; c; fc prek(0); fc preb(0); fc lasx(-INF); fc lasy; fc v(c); //pos.emplace_back(-INF, 0, 0); for (ll _a, _b, i = 1; i &lt;= n; i++) { cin &gt;&gt; _a &gt;&gt; _b; prek = prek + fc(-_a); preb = preb + fc(-_b); pos.emplace_back(frac(-_b, _a), 2 * _a, 2 * _b);// +inf ,+k } pos.emplace_back(INF, 0, 0); lasy = prek * lasx + preb; sort(pos.begin(), pos.end()); bool infi = false; for (auto &amp;p:pos) { fc x, y; ll k, b; tie(x, k, b) = p; y = (prek + k) * x + (preb + b); if (lasy == v &amp;&amp; y == v) { ans.clear(); infi = true; break; } if (lasy &lt;= v &amp;&amp; y &gt; v) { ans.push_back(calc1(lasx, lasy, x, y, v)); } else if (lasy &gt;= v &amp;&amp; y &lt; v) { ans.push_back(calc2(lasx, lasy, x, y, v)); } lasy = y; lasx = x; prek = prek + k; preb = preb + b; } if (infi) { cout &lt;&lt; \"-1\\n\"; } else if (ans.empty()) { cout &lt;&lt; \"0\\n\"; } else { cout &lt;&lt; ans.size() &lt;&lt; \" \"; for (int i = 0; i &lt; ans.size(); i++) cout &lt;&lt; ans[i] &lt;&lt; \" \\n\"[i == ans.size() - 1]; } ans.clear(); pos.clear(); } return 0;}/*42 31 21 -13 32 12 22 32 13 54 -13 21 -11 -21 -3 */","link":"/2019/08/16/CP/Misc/sweep-line-扫描线略知略会/"},{"title":"contest-888-A 单调栈 前缀","text":"题意给一个01矩阵，然后求一个矩阵的最大全1子矩阵数量，这些矩阵要保证，不被其他全一矩阵包含。 思路 官方题解说的很好了，补充：栈里存的高度会要么大于当前up，要么等于当前up，显然等于的时候是不计答案的，大于的时候需要计答案，并且这个矩形的范围其实是从是当前是ij左边的位置开始。（可能和写法有关）。 这样的题目没有想法感觉非常危险。 代码特别地，我枚举j到m+1可以省一次最后的退栈代码。（注释） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;#define _debug(x) cerr&lt;&lt;#x&lt;&lt;\" = \"&lt;&lt;x&lt;&lt;endlusing namespace std;typedef long long ll;const int MAXN = 3e3 + 59;typedef long long ll;int n, m;struct { int up, ls;} stk[MAXN];int up[MAXN][MAXN]; //consecutive 1 above (i,j) (included)int pr[MAXN][MAXN]; //pre sum 1 in the left of (i,j) (included)char str[MAXN];int top;ll ans;int main() { ios_base::sync_with_stdio(0); cin.tie(0); ans = 0; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i) { cin &gt;&gt; (str + 1); for (int j = 1; j &lt;= m; ++j) { up[i][j] = (str[j] == '1') ? (up[i - 1][j] + 1) : 0; pr[i][j] = pr[i][j - 1] + (str[j] - '0'); } } for (int i = 1; i &lt;= n; ++i) { top = 0; for (int j = 1, k; j &lt;= m + 1; ++j) { k = j; while (top &amp;&amp; stk[top].up &gt;= up[i][j]) { k = stk[top].ls; if (stk[top].up &gt; up[i][j]) { int l = stk[top].ls; int r = j - 1; if (pr[i + 1][r] - pr[i + 1][l - 1] != r - l + 1) { ans++; } } top--; } if (up[i][j])stk[++top] = {up[i][j], k}; }// while (top) {// int l = stk[top].ls;// int r = m;// if (pr[i + 1][r] - pr[i + 1][l - 1] != r - l + 1) {// ans++;// }// top--;// } } cout &lt;&lt; ans &lt;&lt; endl; return 0;}","link":"/2019/08/11/CP/Solutions/contest-888-A-单调栈-前缀/"},{"title":"hdu-6638 线段树 最大子段和","text":"题意给你n个坐标，每个坐标有权值（可正可负），目标是找一个平行于坐标轴矩阵，使得矩阵内的取值求和最大，输出最大值。这个矩阵的坐标可以是非整数的，但是输入是整数的，暗示单个点也是可以被框出来的。 思路比较容易想到的是，先离散化坐标，求一个最大子矩阵好像就可以了。 但是想想这个复杂度，对于一个二维数组求最大子矩阵的话，复杂度是$O(n^3)$的，这里2000个点可以对角线排列，那么二维数组的大小就是2000x2000的，三次的复杂度其实不可接受。 然后就去想，这个题里的点其实比较稀疏，只占二维平面里的一点点空间，而一般的做法第三维是需要一次$O(n)$的遍历来做区间最大子段和的，那么在这个问题里我们可以想办法在更少的时间算出最大子段和，并且避开遍历n次的时间。 做法就是用线段树来维护最大子段和，对于那些落在边界内部的点，可以预处理排序所有的点，这样可尺取地逐步放入边界里的点，放完了就可以用线段树得到当前的答案，然后继续移动边界，把下面的点加入线段树，继续计算答案并更新。 这个线段树的设计可以是单点更新$O(log(n))$，并$O(1)$询问的。总体复杂度$O(n^2log(n))$ 数组说明1234ll sum[TreeSize]; //表示区间和ll lft[TreeSize]; //表示当前区间左边开始连续的最大子段和ll rht[TreeSize]; //表示当前区间右边开始连续的最大子段和ll ans[TreeSize]; //表示当前区间的答案（最大字段和） Pro.ID Exe.Time Exe.Memory Language Author 6638 2308MS 1760K G++ tieway59 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161#include &lt;bits/stdc++.h&gt;#define _debug(x) cerr&lt;&lt; #x &lt;&lt; \" = \"&lt;&lt;x &lt;&lt;endlusing namespace std;typedef long long ll;const ll INF = 0x3f3f3f3f;const ll LINF = 0x3f3f3f3f3f3f3f3f;const int MAXN = 4000 + 59;const int TreeSize = MAXN &lt;&lt; 2;struct SegTree {#define lson (oo&lt;&lt;1)#define rson (oo&lt;&lt;1|1) int n; ll sum[TreeSize]; ll lft[TreeSize]; ll rht[TreeSize]; ll ans[TreeSize]; void init(int _n) { this-&gt;n = _n; build(1, 1, _n); } void build(int oo, int l, int r) { if (l == r) { sum[oo] = lft[oo] = rht[oo] = ans[oo] = 0; return; } int m = (l + r) &gt;&gt; 1; build(lson, l, m); build(rson, m + 1, r); sum[oo] = lft[oo] = rht[oo] = ans[oo] = 0; } void update(int oo, int l, int r, int pos, ll val) { if (l == r &amp;&amp; r == pos) { sum[oo] += val;//+val? rht[oo] = max(0ll, sum[oo]); lft[oo] = max(0ll, sum[oo]); ans[oo] = max(0ll, sum[oo]); return; } int m = (l + r) &gt;&gt; 1; if (pos &lt;= m) update(lson, l, m, pos, val); else update(rson, m + 1, r, pos, val); lft[oo] = lft[lson]; rht[oo] = rht[rson]; sum[oo] = sum[lson] + sum[rson]; ans[oo] = max(ans[lson], ans[rson]); ans[oo] = max(ans[oo], rht[lson] + lft[rson]); lft[oo] = max(lft[oo], sum[lson] + lft[rson]); rht[oo] = max(rht[oo], rht[lson] + sum[rson]); if (lft[lson] == sum[lson]) ans[oo] = max(ans[oo], lft[lson] + lft[rson]); if (rht[rson] == sum[rson]) ans[oo] = max(ans[oo], rht[lson] + rht[rson]); } void update(int pos, ll val) { update(1, 1, n, pos, val); } ll query() { return ans[1]; }};SegTree tree;struct point { int x, y, v;} p[MAXN];int dsc[MAXN], dtot;void initDsc() { sort(dsc, dsc + dtot); dtot = unique(dsc, dsc + dtot) - dsc;}int getDsc(const int &amp;val) { return lower_bound(dsc, dsc + dtot, val) - dsc + 1;}int n;ll ans;int Kase;int xmax, ymax;int main() { ios_base::sync_with_stdio(0); cin.tie(0); cin &gt;&gt; Kase; while (Kase--) { ans = 0; dtot = 0; xmax = ymax = 0; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) { cin &gt;&gt; p[i].x &gt;&gt; p[i].y &gt;&gt; p[i].v; dsc[dtot++] = p[i].x; dsc[dtot++] = p[i].y; } initDsc(); for (int i = 1; i &lt;= n; ++i) { p[i].x = getDsc(p[i].x); p[i].y = getDsc(p[i].y); xmax = max(xmax, p[i].x); ymax = max(ymax, p[i].y); } sort(p + 1, p + 1 + n, [](const point &amp;a, const point &amp;b) { if (a.x == b.x)return a.y &lt; b.y; return a.x &lt; b.x; }); for (int l = 1; l &lt;= n; l++) { tree.init(ymax); for (int r = l; r &lt;= n; r++) { tree.update(p[r].y, p[r].v); if (p[r].x != p[r + 1].x) { ans = max(ans, tree.query()); } } while (p[l].x == p[l + 1].x)l++; } cout &lt;&lt; ans &lt;&lt; '\\n'; } return 0;}/*241 1 502 1 501 2 502 2 -5002-1 1 5-1 1 1 */","link":"/2019/08/08/CP/Solutions/hdu-6638-线段树-最大子段和/"}],"tags":[{"name":"github","slug":"github","link":"/tags/github/"},{"name":"建站","slug":"建站","link":"/tags/建站/"},{"name":"照片","slug":"照片","link":"/tags/照片/"},{"name":"单调栈","slug":"单调栈","link":"/tags/单调栈/"},{"name":"前缀和","slug":"前缀和","link":"/tags/前缀和/"},{"name":"线段树","slug":"线段树","link":"/tags/线段树/"},{"name":"hdu","slug":"hdu","link":"/tags/hdu/"}],"categories":[{"name":"CP","slug":"CP","link":"/categories/CP/"},{"name":"Logs","slug":"CP/Logs","link":"/categories/CP/Logs/"},{"name":"Misc","slug":"Misc","link":"/categories/Misc/"},{"name":"Misc","slug":"CP/Misc","link":"/categories/CP/Misc/"},{"name":"Solutions","slug":"CP/Solutions","link":"/categories/CP/Solutions/"}]}