{"pages":[],"posts":[{"title":"Test","text":"index &gt; STL &gt; map 细致的介绍还是前人做的好，我自愧不如。 https://blog.csdn.net/fhb1922702569/article/details/80984774 https://blog.csdn.net/sevenjoin/article/details/81943864 关于比较 列几点我常忽视的细节： 用mp.insert()函数插入已有key的数据时，不能插入数据。而mp[key]引用可改写key对应的value。 map內部的实现自建一颗红黑树，这颗树具有对数据自动排序的功能。（面试可能也会见到相关的提问） 部分应用离散化单纯利用一一对应的特性。 打标记虽然说用 [] 很方便，但是如果就是二元的标记，还是巧用insert/erase/find/count 比较稳妥。（原因有待解释，可能打脸） 特殊二叉搜索树（类红黑树） ——“你其实有一棵随叫随到的红黑树。” 须知： map是有序容器。 mp.begin() 可访问第一个键值对（最值）。 mp[key] 修改某个key的权值，而且改完保持有序。 mp.insert() mp.erase() mp.find() 增删改查都有。 甚至还能自行 mp.lower_bound() mp.upper_bound() 默认lesser&lt;int&gt;升序，想要降序也可以（如果不是原生类型得另外写比较类）： 1map&lt;int, int, greater&lt;int&gt; &gt; cnts; 有了上面这些领悟，你这可以解决某些特定的情况： 比如有一群人，每个人的分数不同，找一下最高分的人有几个。 或者，要输出，第一/第二/第三的分数，和对应的人数。 如果嫌简单，再难一点，修改m次分数，每次修改就再求一次答案。 1e6的人数，1e9的分数，可有负分，修改/询问1e6。 可能以上这个题目比较拙劣，如果以后有更好的会再放进来。简单地说，充分利用key排序和修改方便的特性。","link":"/2019/08/05/Test/"},{"title":"2019.8.6 队内训练","text":"UFBA Practice Session for Brazilian ICPC Regionals - 2018 # Name AC Dsc Stt A Multiset Machine x9 B Color Changing Sofa x140 签到 √- C Renan and Cirque du Soleil x89 推公式 √- D Carnival x25 E Hat-Xor x135 想法/读题 √+ F Renanzinho and His Toys x70 二分/dp/尺取 ○ G Barra Lighthouse x31 H All-In x48 I Colonial Mansions x101 线段树 √- J Soteros x58 K Rei do Cangaço x133 模拟 √- L Code Name Hummingbird x3 M Sorting Machine x41 ○ 代表赛后补题 √+ 代表赛内我通过的 √- 代表赛内不是我做的 √-○代表赛内不是我做的，补了 # = Pen A B C D E F G H I J K L M 1 (64) 5 657 +1 00:29 +2 02:18 + 02:06 -2 -1 +1 03:31 + 01:13","link":"/2019/08/07/2019-8-6-队内训练/"},{"title":"Hexo+ICARUS 使用指南与文章模板","text":"文件头以这篇文章为例，可以知道这每个文件开头面要写这些东西，设置了文件的各种信息。 最好是从bash里hexo new “xxx”这样新建比较好。 12345678910---title: Hexo+ICARUS 使用指南与文章模板date: 2019-08-05 22:05:36tags: - blogsite- postguidetoc: truecategories: - misc--- TBCD···","link":"/2019/08/05/Hexo-ICARUS-使用指南与文章模板/"},{"title":"hdu-6638 线段树 最大子段和","text":"题意给你n个坐标，每个坐标有权值（可正可负），目标是找一个平行于坐标轴矩阵，使得矩阵内的取值求和最大，输出最大值。这个矩阵的坐标可以是非整数的，但是输入是整数的，暗示单个点也是可以被框出来的。 思路比较容易想到的是，先离散化坐标，求一个最大子矩阵好像就可以了。 但是想想这个复杂度，对于一个二维数组求最大子矩阵的话，复杂度是$O(n^3)$的，这里2000个点可以对角线排列，那么二维数组的大小就是2000x2000的，三次的复杂度其实不可接受。 然后就去想，这个题里的点其实比较稀疏，只占二维平面里的一点点空间，而一般的做法第三维是需要一次$O(n)$的遍历来做区间最大子段和的，那么在这个问题里我们可以想办法在更少的时间算出最大子段和，并且避开遍历n次的时间。 做法就是用线段树来维护最大字段和，对于那些落在边界内部的点，可以预处理排序所有的点，这样可尺取地逐步放入边界里的点，放完了就可以用线段树得到当前的答案，然后继续移动边界，把下面的点加入线段树，继续计算答案并更新。 这个线段树的设计可以是单点更新$O(log(n))$，并$O(1)$询问的。总体复杂度$O(n^2log(n))$ 数组说明1234ll sum[TreeSize]; //表示区间和ll lft[TreeSize]; //表示当前区间左边开始连续的最大子段和ll rht[TreeSize]; //表示当前区间右边开始连续的最大子段和ll ans[TreeSize]; //表示当前区间的答案（最大字段和） Pro.ID Exe.Time Exe.Memory Language Author 6638 2308MS 1760K G++ tieway59 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161#include &lt;bits/stdc++.h&gt;#define _debug(x) cerr&lt;&lt; #x &lt;&lt; \" = \"&lt;&lt;x &lt;&lt;endlusing namespace std;typedef long long ll;const ll INF = 0x3f3f3f3f;const ll LINF = 0x3f3f3f3f3f3f3f3f;const int MAXN = 4000 + 59;const int TreeSize = MAXN &lt;&lt; 2;struct SegTree {#define lson (oo&lt;&lt;1)#define rson (oo&lt;&lt;1|1) int n; ll sum[TreeSize]; ll lft[TreeSize]; ll rht[TreeSize]; ll ans[TreeSize]; void init(int _n) { this-&gt;n = _n; build(1, 1, _n); } void build(int oo, int l, int r) { if (l == r) { sum[oo] = lft[oo] = rht[oo] = ans[oo] = 0; return; } int m = (l + r) &gt;&gt; 1; build(lson, l, m); build(rson, m + 1, r); sum[oo] = lft[oo] = rht[oo] = ans[oo] = 0; } void update(int oo, int l, int r, int pos, ll val) { if (l == r &amp;&amp; r == pos) { sum[oo] += val;//+val? rht[oo] = max(0ll, sum[oo]); lft[oo] = max(0ll, sum[oo]); ans[oo] = max(0ll, sum[oo]); return; } int m = (l + r) &gt;&gt; 1; if (pos &lt;= m) update(lson, l, m, pos, val); else update(rson, m + 1, r, pos, val); lft[oo] = lft[lson]; rht[oo] = rht[rson]; sum[oo] = sum[lson] + sum[rson]; ans[oo] = max(ans[lson], ans[rson]); ans[oo] = max(ans[oo], rht[lson] + lft[rson]); lft[oo] = max(lft[oo], sum[lson] + lft[rson]); rht[oo] = max(rht[oo], rht[lson] + sum[rson]); if (lft[lson] == sum[lson]) ans[oo] = max(ans[oo], lft[lson] + lft[rson]); if (rht[rson] == sum[rson]) ans[oo] = max(ans[oo], rht[lson] + rht[rson]); } void update(int pos, ll val) { update(1, 1, n, pos, val); } ll query() { return ans[1]; }};SegTree tree;struct point { int x, y, v;} p[MAXN];int dsc[MAXN], dtot;void initDsc() { sort(dsc, dsc + dtot); dtot = unique(dsc, dsc + dtot) - dsc;}int getDsc(const int &amp;val) { return lower_bound(dsc, dsc + dtot, val) - dsc + 1;}int n;ll ans;int Kase;int xmax, ymax;int main() { ios_base::sync_with_stdio(0); cin.tie(0); cin &gt;&gt; Kase; while (Kase--) { ans = 0; dtot = 0; xmax = ymax = 0; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) { cin &gt;&gt; p[i].x &gt;&gt; p[i].y &gt;&gt; p[i].v; dsc[dtot++] = p[i].x; dsc[dtot++] = p[i].y; } initDsc(); for (int i = 1; i &lt;= n; ++i) { p[i].x = getDsc(p[i].x); p[i].y = getDsc(p[i].y); xmax = max(xmax, p[i].x); ymax = max(ymax, p[i].y); } sort(p + 1, p + 1 + n, [](const point &amp;a, const point &amp;b) { if (a.x == b.x)return a.y &lt; b.y; return a.x &lt; b.x; }); for (int l = 1; l &lt;= n; l++) { tree.init(ymax); for (int r = l; r &lt;= n; r++) { tree.update(p[r].y, p[r].v); if (p[r].x != p[r + 1].x) { ans = max(ans, tree.query()); } } while (p[l].x == p[l + 1].x)l++; } cout &lt;&lt; ans &lt;&lt; '\\n'; } return 0;}/*241 1 502 1 501 2 502 2 -5002-1 1 5-1 1 1 */","link":"/2019/08/08/hdu-6638-线段树-最大子段和/"}],"tags":[{"name":"testin","slug":"testin","link":"/tags/testin/"},{"name":"小结","slug":"小结","link":"/tags/小结/"},{"name":"建站","slug":"建站","link":"/tags/建站/"},{"name":"线段树","slug":"线段树","link":"/tags/线段树/"},{"name":"hdu","slug":"hdu","link":"/tags/hdu/"}],"categories":[{"name":"set","slug":"set","link":"/categories/set/"},{"name":"misc","slug":"misc","link":"/categories/misc/"},{"name":"CP","slug":"CP","link":"/categories/CP/"},{"name":"Solutions","slug":"CP/Solutions","link":"/categories/CP/Solutions/"}]}