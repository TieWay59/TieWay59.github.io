{"pages":[],"posts":[{"title":"Githubæ²¡è®¡ç»¿ç‚¹çš„é—®é¢˜","text":"è¯¦ç»†é—®é¢˜è§ï¼šGithubä¸ºä»€ä¹ˆæ²¡æœ‰è®°å½•ä½ çš„Contributions æˆ‘çš„é—®é¢˜å°±æ˜¯æœ¬åœ°gitçš„è´¦å·å’Œgithubçš„ä¸ä¸€æ ·ï¼Œåœ¨ä¸‹é¢è¿™ä¸ªé¡µé¢æ’å…¥å³å¯ã€‚https://github.com/settings/emails","link":"/2019/08/09/Misc/Githubæ²¡è®¡ç»¿ç‚¹çš„é—®é¢˜/"},{"title":"Qzone ç›¸å†Œç…§ç‰‡é“¾æ¥æµ‹è¯•","text":"ç‰¹åˆ«é¸£è°¢é˜¿ç¿”åŒå­¦è®©æˆ‘æƒ³åˆ°äº†è¿™ä¸ªé—®é¢˜ã€‚","link":"/2019/08/09/Misc/Qzone-ç›¸å†Œç…§ç‰‡é“¾æ¥æµ‹è¯•/"},{"title":"ä¸´æ—¶ç¬”è®°æ ˆ","text":"äº‹æƒ…æ€»ä¼šä¸€ä»¶ä¸€ä»¶Â·Â·Â·å®Œæˆçš„ã€‚ çº¿æ®µæ ‘ç»´æŠ¤æ•°ç»„ å·¦åæ ‘ https://blog.csdn.net/wang3312362136/article/details/80615874 ç¬›å¡å°”æ ‘ å¯å‘å¼åˆå¹¶https://baijiahao.baidu.com/s?id=1613444794783555531&amp;wfr=spider&amp;for=pc Min_25 ç­›é‡æ–°å­¦ä¹ ç¬”è®°https://memset0.cn/min_25 æ–æ³¢é‚£å¥‘å † åˆ’åˆ†æ ‘ï¼Œ ä¸»å¸­æ ‘ï¼Œ äºŒä½çº¿æ®µæ ‘ï¼Œ å·¦åæ ‘ zkwçº¿æ®µæ ‘https://blog.csdn.net/keshuqi/article/details/52205884 å‰å¸æœºçº¿æ®µæ ‘https://blog.csdn.net/di4CoveRy/article/details/54582128 KDæ ‘https://www.cnblogs.com/earendil/p/8135074.htmlhttps://www.cnblogs.com/earendil/p/8135074.htmlhttps://blog.csdn.net/zjx_adstu/article/details/53366546https://www.luogu.org/problem/P4357 1 åˆ° N çš„æ’åˆ—ï¼Œæœ€é•¿ä¸Šå‡å­åºåˆ—ï¼ˆLISï¼‰é•¿åº¦çš„æœŸæœ›æ˜¯å¤šå°‘ï¼Ÿhttps://www.zhihu.com/question/266958886/answer/317982906 æ ‘å½¢èƒŒåŒ… ä¹¦ä¸Šåšä¾èµ–èƒŒåŒ…","link":"/2019/08/08/Misc/ä¸´æ—¶ç¬”è®°æ ˆ/"},{"title":"Hexo+ICARUS ä½¿ç”¨æŒ‡å—ä¸æ–‡ç« æ¨¡æ¿","text":"å°ç™½å…¥é—¨ æ–‡ä»¶å¤´ä»¥è¿™ç¯‡æ–‡ç« ä¸ºä¾‹ï¼Œå¯ä»¥çŸ¥é“è¿™æ¯ä¸ªæ–‡ä»¶å¼€å¤´é¢è¦å†™è¿™äº›ä¸œè¥¿ï¼Œè®¾ç½®äº†æ–‡ä»¶çš„å„ç§ä¿¡æ¯ã€‚ æœ€å¥½æ˜¯ä»bashé‡Œhexo new â€œxxxâ€ åœ¨åå­—ä¹‹å‰å¯ä»¥å¸¦ä¸€ä¸ªæ¨¡æ¿çš„åå­—ï¼ˆä¸ç”¨å¼•å·ï¼‰ï¼Œä¹Ÿå¯ä»¥é¢„å…ˆå‡†å¤‡ä¸€äº›å†™å¥½çš„ä¸œè¥¿ï¼ŒæŒºæ–¹ä¾¿çš„ã€‚ 12345678910---title: Hexo+ICARUS ä½¿ç”¨æŒ‡å—ä¸æ–‡ç« æ¨¡æ¿date: 2019-08-05 22:05:36tags: //æ— é¡ºåºï¼Œå•ä¸€å±‚çº§- blogsite- postguidetoc: true //å¯ç”¨ç« å†…ç´¢å¼•categories: //æœ‰é¡ºåºï¼Œä½“ç°åˆ†ç±»å±‚çº§- misc --- æ’å…¥å›¾ç‰‡ç®€å•çš„åšæ³•æ˜¯å®‰è£…æ’ä»¶ï¼Œ 1npm install hexo-asset-image --save Make sure post_asset_folder: true in your _config.yml. Just use ![logo](logo.jpg) to insert logo.jpg. ä½†æ˜¯ æˆªæ­¢ç›®å‰ï¼Œè¿™ä¸ªæ’ä»¶çš„ä½œè€…å¥½åƒæ²¡æœ‰æ›´æ–°npmçš„åŒ…ï¼Œæ‰€ä»¥githubä¸Šçš„ä»£ç æ˜¯æœ€æ–°çš„ï¼Œæˆ‘æ˜¯ç›´æ¥ä¸‹è½½æ”¾å…¥.\\node_modulesè·¯å¾„é‡Œï¼Œæ‰çœŸæ­£ç”Ÿæ•ˆã€‚ æŠ˜å æ–‡ç« ä½ ä¼šå‘ç°æœ¬æ ·å¼ä¸­çš„æ–‡ç« é»˜è®¤åœ¨ä¸»é¡µæ˜¯ä¸æŠ˜å çš„ï¼Œéœ€è¦åœ¨æ–‡ç« é‡Œå†™ï¼š 1&lt;!--more--&gt; è¿™æ ·çš„ä½œç”¨ä»£è¡¨ä¹‹åçš„å†…å®¹éƒ½ä¼šåœ¨å¤–éƒ¨æŠ˜å éšè—ã€‚ï¼ˆè¥é€ ä¸€ç§ç¥å¥‡çš„æ‘˜è¦çš„é”™è§‰ï¼‰ ä¹Ÿå¯ä»¥åŠ å…¥æ¨¡æ¿ï¼Œçœå¿ƒçœäº‹ã€‚ ç« å¤´å›¾ç‰‡ä¹Ÿå°±æ˜¯ç¼©ç•¥å›¾ï¼Œä¸»è¦çœ‹è¿™é‡Œ https://blog.zhangruipeng.me/hexo-theme-icarus/Configuration/Posts/adding-a-thumbnail-to-your-article/ è®¾ç½®å¥½ä»¥åï¼Œæ–‡ä»¶å¤´é‡ŒåŠ å…¥thumbnail: Â·Â·Â·å°±å¯ä»¥äº†ã€‚ é“¾æ¥ğŸ”—å†™é“¾æ¥å°½é‡å¸¦ä¸Šåè®®ï¼Œä¸ç„¶ä¼šè¢«å®åˆ«æˆè·¯å¾„ã€‚ TBCDÂ·Â·Â·","link":"/2019/08/05/Misc/Hexo-ICARUS-ä½¿ç”¨æŒ‡å—ä¸æ–‡ç« æ¨¡æ¿/"},{"title":"operator overloading é‡è½½è¿ç®—ç¬¦","text":"index &gt; C++ &gt; Operator Overloading æœ‰äº›äº‹æƒ…å¥½åƒç†æ‰€å½“ç„¶ï¼Œä½†æ˜¯åˆä¸é‚£ä¹ˆé¡ºåˆ©ã€‚ æ„é€ å™¨()1234567struct point { int x, y; point() {} // default constructor point (int _x, int _y) { x = _x; y = _y; }}; ä¹Ÿå¯ä»¥è¿™æ ·å†™ï¼š 12345struct point { int x, y; point() {} // default constructor point (int x, int y): x(x), y(y) {}}; æ³¨* æ‹¬å·é‡Œçš„æ˜¯èµ‹å€¼çš„å‚æ•° å¥½åƒå®¹æ˜“è®°é”™ã€‚ å°äºå· &lt;12345678struct point { int x, y; // overloading of &lt; operator bool operator&lt;(const point &amp;rhs) const{ // your main logic for the comparator goes here return make_pair(x,y) &lt; make_pair(rhs.x, rhs.y); }}; è¯·è¦å°å¿ƒå¼±æ¯”è¾ƒçš„ç‰¹æ€§ï¼ˆC++: Strict Weak Orderingï¼‰ï¼Œè‚¯å®šæœ‰äººç–‘æƒ‘è¿‡ä¸ºä»€ä¹ˆåªè¦å®šä¹‰ä¸€ä¸ªå°äºå·ã€‚å› ä¸ºå¯¹ä¸‰ç§å¤§å°å…³ç³»å¯ä»¥åªç”¨ä¸€ä¸ªæ¥å®ç°ï¼Œåªä¸è¿‡ç­‰äºçš„çŠ¶æ€è¦æ¯”è¾ƒä¸¤æ¬¡ï¼Œæ¯”å¦‚a&lt;bå’Œb&lt;aç»“æœéƒ½ä¸ºå‡ï¼Œé‚£ä¹ˆå°±åˆ¤æ–­ä¸ºä¸¤è€…ç›¸ç­‰ã€‚ å¦‚æœä½ åœ¨å®šä¹‰ä¸¥æ ¼å°çš„è¿‡ç¨‹ä¸­ï¼Œè¯¯ç”¨äº†ç­‰å·ï¼Œä¼šå¯¼è‡´éš¾ä»¥é¢„æ–™çš„ç»“æœã€‚è€Œä¸”å¾ˆå¯èƒ½è‡ªå·±æµ‹è¯•å¯¹äº†ï¼ŒæŸäº›æ ·ä¾‹è¿‡ä¸äº†ã€‚ å¯ä»¥è¿™æ ·å»ç†è§£ï¼šå¦‚æœæ»¡è¶³æ¡ä»¶çš„æ—¶å€™ï¼Œæœ¬èº«è¿™ä¸ªå…ƒç´ ï¼Œä¸€å®šæ”¾åœ¨å¦å¤–ä¸€ä¸ªå…ƒç´ ä¹‹å‰ï¼Œåˆ™è¿™ä¸ªæ¡ä»¶è¦è¿”è¿˜çœŸã€‚ å¯èƒ½æœ‰äººä¼šè§‰å¾—) const {è¿™ä¸ªå­¤é›¶é›¶çš„å¾ˆå¥‡æ€ªï¼Œä½†æ˜¯è¿™ä¸ªæ˜¯å¿…è¦çš„è¯­æ³•ç»“æ„ã€‚å°¤å…¶æ˜¯åœ¨è¢«ç”¨äºmapæˆ–è€…ä¼˜å…ˆé˜Ÿåˆ—ä¹‹ç±»keyçš„æ—¶å€™ã€‚ &lt;&lt;æ³¨* å¿…é¡»è¦å…¨å±€å‡½æ•°çš„å½¢å¼ï¼ˆåŸç†æš‚ç•¥ï¼‰reference 12345678struct node { int x,y; friend ostream &amp; operator &lt;&lt; (ostream &amp;out,node &amp;T);};ostream &amp; operator &lt;&lt; (ostream &amp;out,node &amp;T){ out&lt;&lt;T.x&lt;&lt;\" \"&lt;&lt;T.y; return out;} æ™®é€š()å¥½åƒæ˜¯æœ‰æ‹¬å·çš„è®¡ç®—æ˜¯éœ€è¦çš„ï¼ˆæœªè¯å®ï¼‰ 1234struct node { int x,y; node operator ()(const node &amp;T){return T;}}; è®¡ç®—12345678910struct node { int x,y; node ():x(0),y(0){} node (int x,int y):x(x),y(y){} int len(){return x*x+y*y;} node operator - (const node &amp;T){return node(x-T.x,y-T.y);} node operator + (const node &amp;T){return node(x+T.x,y+T.y);} int operator * (const node &amp;T){return x*T.x+y*T.y;} int operator / (const node &amp;T){return x*T.y-y*T.x;}//å‰ç§¯}; ä¾‹é¢˜ä¸€èˆ¬éƒ½æ˜¯åœ¨åæ ‡è¿ç®—ï¼Œæˆ–è€…æ¯”è¾ƒç‰¹æ®Šçš„æ¨¡æ‹Ÿçš„æ—¶å€™éœ€è¦ç”¨åˆ°è¿™äº›ã€‚CodeForces - 136D :: Mine :: Dalao å‚è€ƒUsing Constructors and comparison function in C++ By PraveenDhinwa","link":"/2019/09/16/CP/C++/operator overloading é‡è½½è¿ç®—ç¬¦/"},{"title":"common sense","text":"ä¸‹é¢å†™ä¸€äº›åº”è¯¥å¾ˆå¤šäººéƒ½çŸ¥é“ï¼Œä½†æ˜¯å…¶å®åˆšå…¥é—¨çš„æ—¶å€™ä¼šè§‰å¾—å¾ˆè¿·æƒ‘çš„äº‹æƒ…ã€‚ __int128 æœ¬åœ°è¿è¡Œè¿™ä¸ªé—®é¢˜æˆ‘åªçŸ¥é“ä¸€äº›æƒ…å†µï¼š é¦–å…ˆè¿™æ˜¯ç¼–è¯‘å™¨çš„åŸå› ï¼ŒGCC / Mingw-w64ç‰ˆæœ¬å·é«˜äº†å°±å¯ä»¥è¿è¡Œäº†ã€‚ Code::Blocks 17.12 å¦‚æœè£…äº†å®˜ç½‘çš„å¥—è£…ç‰ˆçš„è¯æ˜¯ç¼–è¯‘ä¸äº†ã€‚ï¼ˆæ²¡è¯•è¿‡æ¢ï¼‰ CLioné…å¥—mingw-w64ä¸‹è½½çš„é«˜ç‰ˆæœ¬çš„toolchainæ˜¯å¯ä»¥çš„ã€‚ VSé«˜ç‰ˆæœ¬çš„ä¸€èˆ¬éƒ½å¯ä»¥ã€‚ æˆ‘æ˜¯ç”¨CLionçš„ã€‚","link":"/2019/09/16/CP/C++/common-sense/"},{"title":"sort æ’åº","text":"std::sortåœ¨æ¼«é•¿çš„CPå²æœˆä¸­ï¼Œä½ å¯èƒ½ä¼šå­¦ä¼šå„ç§å„æ ·çš„åˆ©ç”¨std::sortçš„æ–¹æ³•ï¼Œæ¯”å¦‚é‡è½½è¿ç®—ç¬¦ï¼Œæˆ–è€…å†™æ¯”è¾ƒå‡½æ•°ã€‚åŒæ—¶æ¸æ¸å¿˜è®°å¦‚ä½•å†™å¿«æ’ ç”šè‡³ä¸€ç§å°‘è§ï¼ˆæŸç§ç¨‹åº¦ä¸Šå¾ˆåˆç†ï¼‰çš„å†…è”å†™æ³•c++11ï¼š 123sort(A.begin(), A.end(), [](const Type&amp; a, const Type&amp; b) { return a.day &lt; b.day; }); tbcdâ€¦","link":"/2019/09/16/CP/C++/sort æ’åº/"},{"title":"unordered_map","text":"index &gt; STL &gt; unordered_map ç®€ä»‹å†…éƒ¨å®ç°å“ˆå¸Œçš„mapï¼Œç›¸å¯¹äºä¸€èˆ¬mapæ¥è¯´ï¼Œç†è®ºä¸Šæ›´å¿«ã€‚ åº”ç”¨åŸºæœ¬å’Œæ™®é€šmapç±»ä¼¼ï¼Œç”šè‡³æœ‰æ—¶å€™ä¼šè®©äººè§‰å¾—unordered_mapæ›´ç¬¦åˆæˆ‘ä»¬çš„éœ€æ±‚ï¼Œå› ä¸ºæˆ‘ä»¬unordered_mapçš„ä¿®æ”¹æŸ¥è¯¢å¾ˆå¿«ï¼Œä½†éå†å¾ˆæ…¢ï¼Œä¸€èˆ¬æˆ‘ä»¬å¼€mapä¹Ÿä¸ç”¨åˆ°éå†ã€‚ unordered_mapå¯¹keyçš„è¦æ±‚æ˜¯éœ€è¦å®ç°å…¶å“ˆå¸Œè¿‡ç¨‹ï¼Œé»˜è®¤çš„å“ˆå¸Œæ”¯æŒæ•´æ•°ç±»å‹çš„keyã€‚ ç¼ºé™·ä¸æ”¹è¿›ç†è®ºä¸Šæ›´å¿«çš„ï¼Œä½†æœ‰ä¾‹å¤–ï¼Œè€Œä¸”å¾ˆå¯èƒ½ä¼šå½±å“åˆ°ä¸€äº›ç‰¹å®šæ ·ä¾‹çš„è¿è¡Œæ—¶é—´ã€‚ å› ä¸ºä¸€èˆ¬çš„ç¼–è¯‘å™¨ï¼Œç»™unordered_mapé»˜è®¤çš„å“ˆå¸Œè¡¨æ˜¯å›ºå®šçš„ï¼Œå½“ç„¶ç»†èŠ‚æŒºå¤æ‚ï¼Œè¯¦ç»†å¯ä»¥çœ‹å‚è€ƒé‡Œçš„é‚£ç¯‡åšå®¢ã€‚ ç¬”è€…å°±è¯´ä¸€ä¸ªå¾ˆç®€é™‹çš„ç†è§£ï¼š é»˜è®¤çš„å“ˆå¸Œåœ¨å¤„ç†å†²çªçš„æ—¶å€™ï¼Œæ˜¯å€ŸåŠ©å›ºå®šçš„å“ˆå¸Œè¡¨æ¥åç§»çš„ï¼Œå†²çªè¶Šå¤šéœ€è¦çš„æ—¶é—´è¶Šå¤šã€‚å½“æœ‰é’ˆå¯¹æ€§åœ°hackæ—¶ï¼Œæœ€å·®ä¼šé€€åŒ–æˆ$O(N^2)$ çš„è¿‡ç¨‹ã€‚ ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œä¸€èˆ¬éƒ½ä¼šè‡ªå†™å“ˆå¸Œè¿‡ç¨‹ï¼Œ ä¸‹é¢æ˜¯å¤§ä½¬çš„ä¼˜ç§€å®ç°ï¼š 12345678910111213141516struct custom_hash { static uint64_t splitmix64(uint64_t x) { // http://xorshift.di.unimi.it/splitmix64.c x += 0x9e3779b97f4a7c15; x = (x ^ (x &gt;&gt; 30)) * 0xbf58476d1ce4e5b9; x = (x ^ (x &gt;&gt; 27)) * 0x94d049bb133111eb; return x ^ (x &gt;&gt; 31); } size_t operator()(uint64_t x) const { static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count(); return splitmix64(x + FIXED_RANDOM); }};unordered_map&lt;long long, int, custom_hash&gt; safe_map; å¯ä»¥è¯´ï¼Œå“ˆå¸Œå¾—æ›´å¥½ï¼Œèƒ½æé«˜æ€§èƒ½ã€‚ å‚è€ƒBlowing up unordered_map, and how to stop getting hacked on it by neal C++ STL: Order of magnitude faster hash tables with Policy Based Data Structures by Chilli","link":"/2019/09/16/CP/C++/unordered_map/"},{"title":"Connected Components è¿é€šåˆ†é‡åŠç›¸å…³ç®—æ³•","text":"å¼•å­è¿™æ˜¯ä¸€ç¯‡ä¹…å’•ä¹‹ä½œã€‚ æ¨¡æ¿todo å¼•å¯¼é¦–å…ˆï¼Œå‡è®¾æˆ‘ä»¬ç”¨çš„æ˜¯å‰å‘æ˜Ÿå»ºå›¾ã€‚ 12345678910struct Edge { int u, v, nx; // ,w} e[MAXN &lt;&lt; 1];int head[MAXN], cntEd;inline void addEdge(int u, int v) { e[cntEd] = {u, v, head[u]}; head[u] = cntEd++;} ç„¶ååº”è¯¥å†™ä¸€ä¸ªDFSã€‚ 123456789void tarjan(int u) { for (int i = head[u]; ~i; i = e[i].nx) { int v = e[i].v; if ( ) { } } if ( ) { }} ä¸‹é¢æƒ³éœ€è¦ç”¨åˆ°ä»€ä¹ˆæ•°ç»„ã€‚ 1234int low[MAXN]; //LOWLINKint dfn[MAXN], idx; //NUMBERint stk[MAXN], top; //STACK for ccint scc[MAXN], sccnum; //SCC tags ç„¶åæƒ³ä¸€ä¸‹æ¯ä¸ªæ•°ç»„çš„æ„ä¹‰ï¼Œå¡«è¿›DFSã€‚ 12345678910111213141516171819202122232425void tarjan(int u) { dfn[u] = low[u] = ++idx; stk[++top] = u; for (int i = head[u]; ~i; i = e[i].nx) { int v = e[i].v; if (!dfn[v]) { //å¦‚æœvç»“ç‚¹æœªè®¿é—®è¿‡ tarjan(v); low[u] = min(low[u], low[v]); } else if (!scc[v]) { //å¦‚æœè¿˜åœ¨æ ˆå†… low[u] = min(low[u], dfn[v]); } } if (low[u] == dfn[u]) { //åä»£ä¸èƒ½æ‰¾åˆ°æ›´æµ…çš„ç‚¹ sccnum++; int x; do { x = stk[top--]; scc[x] = sccnum; } while (x != u); }} ç„¶åå­¦ä¼šæ€ä¹ˆç”¨å®ƒã€‚ 12345678910111213141516int main() { memset(head, -1, sizeof head); int n; //input &amp; build graph ... for (int i = 1; i &lt;= n; ++i) { if (!dfn[i]) tarjan(i); } //scc[v] ... return 0;} å¥½äº†å‡è£…ä½ ä¼šäº†ã€‚ å½“ç„¶è¦çœŸçš„ä¼šäº†ï¼Œå¯ä»¥è¯•å›¾å»ç†è§£ä¸€ä¸‹ï¼ŒDFSä¸­çš„æ¡ä»¶ã€‚ ä¾‹é¢˜SCC / Directed Roadsç»™ä¸€ä¸ªnç‚¹nè¾¹æœ‰å‘æ— æƒå›¾ã€‚é—®ï¼Œæœ‰å¤šå°‘ç§åè½¬è¾¹çš„æ–¹æ¡ˆï¼Œä½¿å›¾ä¸­æ— ç®€å•ç¯ã€‚ æ€è·¯ä¹Ÿç®€å•ï¼Œæ¯æ¡è¾¹åè½¬å’Œä¸åè½¬æœ‰$2^n$ç§æ–¹æ¡ˆã€‚å‡å¦‚æœ‰ä¸€ä¸ª$m$é˜¶ç¯ï¼Œæœ‰ä¸¤ç§æ–¹æ¡ˆæ˜¯ä¸è¡Œçš„â€”â€”å…¨åè½¬å’Œå…¨ä¸åè½¬ã€‚æ‰€ä»¥å¯¹æ¯ä¸ª$m_i$é˜¶ç¯ï¼Œå…¶å®æ–¹æ¡ˆæœ‰$2^{m_i}-2$ç§æ–¹æ¡ˆã€‚ å…¶ä»–è¾¹éƒ½å½“$2$ç´¯ä¹˜å³å¯ã€‚ æˆ‘çš„ä»£ç ï¼š60847488 Tarjan 1972","link":"/2019/09/20/CP/Graph/Connected-Components-è¿é€šåˆ†é‡åŠç›¸å…³ç®—æ³•/"},{"title":"random ä¼ªéšæœºï¼Œä¸æ›´å¥½çš„ä¼ªéšæœº","text":"index &gt; STL &gt; random ä¸»è¦å†…å®¹å¦‚æœæ”¯æŒC++11çš„è¯ï¼Œå°±åƒä¸‹é¢è¿™æ ·å†™éšæœºæ•°ï¼š (ä¸‹é¢ä¸¤ä¸ªå†™æ³•éƒ½è¡¨ç¤ºå¾—åˆ°ä¸€ä¸ª$[0,10]$çš„intå‹éšæœºæ•°) 123456789101112131415161718#include &lt;chrono&gt;#include &lt;iostream&gt;#include &lt;random&gt;using namespace std;int main() { mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); //minstd_rand rng(chrono::steady_clock::now().time_since_epoch().count()); for (int i = 0; i &lt; 10; ++i) { cout &lt;&lt; uniform_int_distribution&lt;int&gt;(0, 10)(rng) &lt;&lt; endl; } uniform_int_distribution&lt;int&gt; u(0, 10); for (int i = 0; i &lt; 10; ++i) { cout &lt;&lt; u(rng) &lt;&lt; endl; }} 123456//ç®€å•ä»£ç mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());inline int suiJi(const int &amp;l, const int &amp;r) { return uniform_int_distribution&lt;int&gt;(l, r)(rng);} æ³¨é‡Šï¼š chronoåº“æä¾›äº†ä¸€ä¸ªé«˜ç²¾æ—¶é’Ÿï¼Œç²¾ç¡®åˆ°æ¯«ç§’ï¼Œå˜åŒ–å‘¨æœŸæ›´çŸ­ã€‚ uniform_int_distributionå¯ä»¥äº§ç”Ÿåœ¨ä¸€ä¸ªèŒƒå›´ä¸Šå‡åŒ€åˆ†å¸ƒçš„æ•´æ•°å€¼ã€‚å¯¹äºå…¶ä»–åˆ†å¸ƒéœ€æ±‚å¯ä»¥çœ‹è¿™é‡Œ minstd_rand å¼•æ“å®ç°çº¿æ€§åŒä½™ç®—æ³•ã€‚çº¿æ€§åŒä½™å¼•æ“ä¸€èˆ¬åœ°å¿«ï¼Œå¹¶å¯¹çŠ¶æ€çš„å­˜å‚¨è¦æ±‚éå¸¸å°ã€‚ mt19937 å¼•æ“å®ç°æ¢…æ£®ç¼ ç»•å™¨ç®—æ³•ã€‚æ¢…æ£®ç¼ ç»•å™¨è¾ƒæ…¢ä¸”æ‹¥æœ‰è¾ƒå¤§çš„çŠ¶æ€å­˜å‚¨è¦æ±‚ï¼Œä½†åªè¦æœ‰æ­£ç¡®çš„å‚æ•°ï¼Œå°±ä¼šæœ‰æœ€é•¿çš„çš„ä¸å¯é‡å¤åºåˆ—ï¼Œä¸”æ‹¥æœ‰æœ€æƒ³è¦çš„å…‰è°±ç‰¹æ€§ï¼ˆå¯¹äºç»™å®šçš„æƒ³è¦çš„å®šä¹‰ï¼‰ã€‚ å¦å¤–è¿™äº›ä¸œè¥¿å¯èƒ½ä¸ä¼šå¾ˆå¿«ï¼Œä¹Ÿä¸ä¸€å®šæ´¾ä¸Šç”¨åœºã€‚ ä¸æ¨èå†™æ³•è¿™ä¸ªç”Ÿæˆæ–¹æ³•çš„æœ€å¤§å€¼ä¸ä¸€å®šèƒ½è¦†ç›–intï¼ˆä¸ç¼–è¯‘ç¯å¢ƒæœ‰å…³ï¼‰ï¼Œè€Œè´¨é‡ä¸é«˜ã€‚è°¨æ…ä½¿ç”¨ã€‚ 1234567891011#include &lt;time.h&gt;#include &lt;iostream&gt;#include &lt;random&gt;using namespace std;int main() { srand(time(0)); for (int i = 0; i &lt; 10; ++i) { cout&lt;&lt;rand()%10&lt;&lt;endl; } å‚è€ƒä¼ªéšæœºæ•°ç”Ÿæˆ Donâ€™t use rand(): a guide to random number generators in C++","link":"/2019/09/16/CP/C++/random ä¼ªéšæœºï¼Œä¸æ›´å¥½çš„ä¼ªéšæœº/"},{"title":"2019.8.6 é˜Ÿå†…è®­ç»ƒ","text":"UFBA Practice Session for Brazilian ICPC Regionals - 2018 # Name AC Dsc Stt A Multiset Machine x9 B Color Changing Sofa x140 ç­¾åˆ° âˆš- C Renan and Cirque du Soleil x89 æ¨å…¬å¼ âˆš- D Carnival x25 E Hat-Xor x135 æƒ³æ³•/è¯»é¢˜ âˆš+ F Renanzinho and His Toys x70 äºŒåˆ†/dp/å°ºå– â—‹ G Barra Lighthouse x31 H All-In x48 I Colonial Mansions x101 çº¿æ®µæ ‘ âˆš- J Soteros x58 K Rei do CangaÃ§o x133 æ¨¡æ‹Ÿ âˆš- L Code Name Hummingbird x3 M Sorting Machine x41 â—‹ ä»£è¡¨èµ›åè¡¥é¢˜ âˆš+ ä»£è¡¨èµ›å†…æˆ‘é€šè¿‡çš„ âˆš- ä»£è¡¨èµ›å†…ä¸æ˜¯æˆ‘åšçš„ âˆš-â—‹ä»£è¡¨èµ›å†…ä¸æ˜¯æˆ‘åšçš„ï¼Œè¡¥äº† # = Pen A B C D E F G H I J K L M 1 (64) 5 657 +1 00:29 +2 02:18 + 02:06 -2 -1 +1 03:31 + 01:13","link":"/2019/08/07/CP/Logs/2019-8-6-é˜Ÿå†…è®­ç»ƒ/"},{"title":"sweep line æ‰«æçº¿ç•¥çŸ¥ç•¥ä¼š","text":"åšäº†ä¸€äº›æœ‰ç›¸åŒæ€è·¯çš„é¢˜ï¼Œå…ˆç•™ä¸ªå‘ã€‚ æ€è·¯ ğŸŒ 2019/8/16 21:48:22æˆ‘çš„ç†è§£æ˜¯ å¯¹ä¸€äº›äº‹ä»¶æ ¹æ®ä¸€å®šé¡ºåºæ’åºç„¶åfor â€‹ â€”â€”è¾°å·¨å¦‚æ˜¯è¯´ å¾…é˜…è¯»https://codeforces.com/blog/entry/20377 https://blog.csdn.net/xianpingping/article/details/83032798 https://blog.csdn.net/sslz_fsy/article/details/82902644 ä¾‹é¢˜ä¸ä¾‹ç¨‹ZJNU 1426(å¼Šæ ¡OJï¼Œå¯èƒ½æ‰“ä¸å¼€) 12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;int n,cur,ans;map&lt;int, int&gt; cnt;int main() { ios_base::sync_with_stdio(0); cin.tie(0); cin &gt;&gt; n; for (int a, b, i = 1; i &lt;= n; i++) { cin &gt;&gt; a &gt;&gt; b; cnt[a - 1]++; cnt[b]--; } for (auto pi:cnt) { ans = max(ans, cur); cur += pi.second; } cout &lt;&lt; ans &lt;&lt; endl; return 0;} NCOJ 889D Symmetrical Painting2019ç‰›å®¢æš‘æœŸå¤šæ ¡è®­ç»ƒè¥ï¼ˆç¬¬ä¹åœºï¼‰J 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt; #define get0(x) get&lt;0&gt;(x)#define get1(x) get&lt;1&gt;(x)#define _debug(x) cerr&lt;&lt;#x&lt;&lt;\" = \"&lt;&lt;x&lt;&lt;endlusing namespace std;typedef long long ll;const int MAXN = 1e6 + 59;const ll MOD = 1e9 + 7; ll n, ans;vector&lt;tuple&lt;int, int&gt; &gt; pos; int main() { ios_base::sync_with_stdio(0); cin.tie(0); cin &gt;&gt; n; pos.emplace_back(0, 0); for (ll l, r, i = 1; i &lt;= n; i++) { cin &gt;&gt; l &gt;&gt; r; pos.emplace_back(l + l, 1); pos.emplace_back(l + r, -2); pos.emplace_back(r + r, 1); } sort(pos.begin(), pos.end()); ll cur = 0; ll del = 0; ll las = 0; for (auto &amp;p:pos) { cur += (get0(p) - las) * del; del += get1(p); las = get0(p); ans = max(ans, cur); } cout &lt;&lt; ans &lt;&lt; endl; return 0;} HDU 6627HDU 2019 Multi-University Training Contest 5 è¿™é¢˜mainå‡½æ•°é‡Œå…¶å®ä¸å¤æ‚ï¼Œä½†æ˜¯åˆ†æ•°å¯çœŸæ˜¯ææ­»æˆ‘äº†ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193#include &lt;bits/stdc++.h&gt;#define get0(x) get&lt;0&gt;(x)#define get1(x) get&lt;1&gt;(x)#define get2(x) get&lt;2&gt;(x)#define _debug(x) cerr&lt;&lt;#x&lt;&lt;\" = \"&lt;&lt;x&lt;&lt;endlusing namespace std;typedef long long ll;const int MAXN = 1e6 + 59;const ll MOD = 1e9 + 7;const ll INF = 1001;typedef struct frac { ll a, b; frac() : a(0), b(1) {} frac(ll _a) : a(_a), b(1) {} frac(ll _a, ll _b) : a(_a), b(_b) { if (a == 0) { this-&gt;b = 1; } if (b &lt; 0) { this-&gt;a = -_a; this-&gt;b = -_b; } ll g = __gcd(abs(a), abs(b)); this-&gt;a /= g; this-&gt;b /= g; } frac operator+(const frac &amp;rht) const { return frac(a * rht.b + b * rht.a, b * rht.b); } frac operator-(const frac &amp;rht) const { return frac(a * rht.b - b * rht.a, b * rht.b); } frac operator*(const frac &amp;rht) const { return frac(a * rht.a, b * rht.b); } frac operator/(const frac &amp;rht) const { return frac(a * rht.b, b * rht.a); } bool operator&lt;(const frac &amp;rht) const { return a * rht.b &lt; b * rht.a; } bool operator&lt;=(const frac &amp;rht) const { return a * rht.b &lt;= b * rht.a; } bool operator&gt;(const frac &amp;rht) const { return a * rht.b &gt; b * rht.a; } bool operator&gt;=(const frac &amp;rht) const { return a * rht.b &gt;= b * rht.a; } bool operator==(const frac &amp;rht) const { return a * rht.b == b * rht.a; } friend ostream &amp;operator&lt;&lt;(ostream &amp;out, frac &amp;T); void operator()(ll _a, ll _b) { *this = frac(_a, _b); }} fc;ostream &amp;operator&lt;&lt;(ostream &amp;out, fc &amp;T) { out &lt;&lt; T.a &lt;&lt; \"/\" &lt;&lt; T.b; return out;}// y1&lt;y2fc calc1(fc x1, fc y1, fc x2, fc y2, fc c) { fc dx = x2 - x1; fc dy = y2 - y1; fc dc = c - y1; return x1 + dc * dx / dy;}// y1&gt;y2fc calc2(fc x1, fc y1, fc x2, fc y2, fc c) { fc dx = x2 - x1; fc dy = y1 - y2; fc dc = c - y2; return x2 - dc * dx / dy;}ll n, kase, c;vector&lt;tuple&lt;fc, ll, ll&gt; &gt; pos;vector&lt;fc&gt; ans;int main() { ios_base::sync_with_stdio(0); cin.tie(0); cin &gt;&gt; kase; while (kase--) { ans.clear(); pos.clear(); cin &gt;&gt; n &gt;&gt; c; fc prek(0); fc preb(0); fc lasx(-INF); fc lasy; fc v(c); //pos.emplace_back(-INF, 0, 0); for (ll _a, _b, i = 1; i &lt;= n; i++) { cin &gt;&gt; _a &gt;&gt; _b; prek = prek + fc(-_a); preb = preb + fc(-_b); pos.emplace_back(frac(-_b, _a), 2 * _a, 2 * _b);// +inf ,+k } pos.emplace_back(INF, 0, 0); lasy = prek * lasx + preb; sort(pos.begin(), pos.end()); bool infi = false; for (auto &amp;p:pos) { fc x, y; ll k, b; tie(x, k, b) = p; y = (prek + k) * x + (preb + b); if (lasy == v &amp;&amp; y == v) { ans.clear(); infi = true; break; } if (lasy &lt;= v &amp;&amp; y &gt; v) { ans.push_back(calc1(lasx, lasy, x, y, v)); } else if (lasy &gt;= v &amp;&amp; y &lt; v) { ans.push_back(calc2(lasx, lasy, x, y, v)); } lasy = y; lasx = x; prek = prek + k; preb = preb + b; } if (infi) { cout &lt;&lt; \"-1\\n\"; } else if (ans.empty()) { cout &lt;&lt; \"0\\n\"; } else { cout &lt;&lt; ans.size() &lt;&lt; \" \"; for (int i = 0; i &lt; ans.size(); i++) cout &lt;&lt; ans[i] &lt;&lt; \" \\n\"[i == ans.size() - 1]; } ans.clear(); pos.clear(); } return 0;}/*42 31 21 -13 32 12 22 32 13 54 -13 21 -11 -21 -3 */","link":"/2019/08/16/CP/Misc/sweep-line-æ‰«æçº¿ç•¥çŸ¥ç•¥ä¼š/"},{"title":"hdu-6638 çº¿æ®µæ ‘ æœ€å¤§å­æ®µå’Œ","text":"é¢˜æ„ç»™ä½ nä¸ªåæ ‡ï¼Œæ¯ä¸ªåæ ‡æœ‰æƒå€¼ï¼ˆå¯æ­£å¯è´Ÿï¼‰ï¼Œç›®æ ‡æ˜¯æ‰¾ä¸€ä¸ªå¹³è¡Œäºåæ ‡è½´çŸ©é˜µï¼Œä½¿å¾—çŸ©é˜µå†…çš„å–å€¼æ±‚å’Œæœ€å¤§ï¼Œè¾“å‡ºæœ€å¤§å€¼ã€‚è¿™ä¸ªçŸ©é˜µçš„åæ ‡å¯ä»¥æ˜¯éæ•´æ•°çš„ï¼Œä½†æ˜¯è¾“å…¥æ˜¯æ•´æ•°çš„ï¼Œæš—ç¤ºå•ä¸ªç‚¹ä¹Ÿæ˜¯å¯ä»¥è¢«æ¡†å‡ºæ¥çš„ã€‚ æ€è·¯æ¯”è¾ƒå®¹æ˜“æƒ³åˆ°çš„æ˜¯ï¼Œå…ˆç¦»æ•£åŒ–åæ ‡ï¼Œæ±‚ä¸€ä¸ªæœ€å¤§å­çŸ©é˜µå¥½åƒå°±å¯ä»¥äº†ã€‚ ä½†æ˜¯æƒ³æƒ³è¿™ä¸ªå¤æ‚åº¦ï¼Œå¯¹äºä¸€ä¸ªäºŒç»´æ•°ç»„æ±‚æœ€å¤§å­çŸ©é˜µçš„è¯ï¼Œå¤æ‚åº¦æ˜¯$O(n^3)$çš„ï¼Œè¿™é‡Œ2000ä¸ªç‚¹å¯ä»¥å¯¹è§’çº¿æ’åˆ—ï¼Œé‚£ä¹ˆäºŒç»´æ•°ç»„çš„å¤§å°å°±æ˜¯2000x2000çš„ï¼Œä¸‰æ¬¡çš„å¤æ‚åº¦å…¶å®ä¸å¯æ¥å—ã€‚ ç„¶åå°±å»æƒ³ï¼Œè¿™ä¸ªé¢˜é‡Œçš„ç‚¹å…¶å®æ¯”è¾ƒç¨€ç–ï¼Œåªå äºŒç»´å¹³é¢é‡Œçš„ä¸€ç‚¹ç‚¹ç©ºé—´ï¼Œè€Œä¸€èˆ¬çš„åšæ³•ç¬¬ä¸‰ç»´æ˜¯éœ€è¦ä¸€æ¬¡$O(n)$çš„éå†æ¥åšåŒºé—´æœ€å¤§å­æ®µå’Œçš„ï¼Œé‚£ä¹ˆåœ¨è¿™ä¸ªé—®é¢˜é‡Œæˆ‘ä»¬å¯ä»¥æƒ³åŠæ³•åœ¨æ›´å°‘çš„æ—¶é—´ç®—å‡ºæœ€å¤§å­æ®µå’Œï¼Œå¹¶ä¸”é¿å¼€éå†næ¬¡çš„æ—¶é—´ã€‚ åšæ³•å°±æ˜¯ç”¨çº¿æ®µæ ‘æ¥ç»´æŠ¤æœ€å¤§å­æ®µå’Œï¼Œå¯¹äºé‚£äº›è½åœ¨è¾¹ç•Œå†…éƒ¨çš„ç‚¹ï¼Œå¯ä»¥é¢„å¤„ç†æ’åºæ‰€æœ‰çš„ç‚¹ï¼Œè¿™æ ·å¯å°ºå–åœ°é€æ­¥æ”¾å…¥è¾¹ç•Œé‡Œçš„ç‚¹ï¼Œæ”¾å®Œäº†å°±å¯ä»¥ç”¨çº¿æ®µæ ‘å¾—åˆ°å½“å‰çš„ç­”æ¡ˆï¼Œç„¶åç»§ç»­ç§»åŠ¨è¾¹ç•Œï¼ŒæŠŠä¸‹é¢çš„ç‚¹åŠ å…¥çº¿æ®µæ ‘ï¼Œç»§ç»­è®¡ç®—ç­”æ¡ˆå¹¶æ›´æ–°ã€‚ è¿™ä¸ªçº¿æ®µæ ‘çš„è®¾è®¡å¯ä»¥æ˜¯å•ç‚¹æ›´æ–°$O(log(n))$ï¼Œå¹¶$O(1)$è¯¢é—®çš„ã€‚æ€»ä½“å¤æ‚åº¦$O(n^2log(n))$ æ•°ç»„è¯´æ˜1234ll sum[TreeSize]; //è¡¨ç¤ºåŒºé—´å’Œll lft[TreeSize]; //è¡¨ç¤ºå½“å‰åŒºé—´å·¦è¾¹å¼€å§‹è¿ç»­çš„æœ€å¤§å­æ®µå’Œll rht[TreeSize]; //è¡¨ç¤ºå½“å‰åŒºé—´å³è¾¹å¼€å§‹è¿ç»­çš„æœ€å¤§å­æ®µå’Œll ans[TreeSize]; //è¡¨ç¤ºå½“å‰åŒºé—´çš„ç­”æ¡ˆï¼ˆæœ€å¤§å­—æ®µå’Œï¼‰ Pro.ID Exe.Time Exe.Memory Language Author 6638 2308MS 1760K G++ tieway59 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161#include &lt;bits/stdc++.h&gt;#define _debug(x) cerr&lt;&lt; #x &lt;&lt; \" = \"&lt;&lt;x &lt;&lt;endlusing namespace std;typedef long long ll;const ll INF = 0x3f3f3f3f;const ll LINF = 0x3f3f3f3f3f3f3f3f;const int MAXN = 4000 + 59;const int TreeSize = MAXN &lt;&lt; 2;struct SegTree {#define lson (oo&lt;&lt;1)#define rson (oo&lt;&lt;1|1) int n; ll sum[TreeSize]; ll lft[TreeSize]; ll rht[TreeSize]; ll ans[TreeSize]; void init(int _n) { this-&gt;n = _n; build(1, 1, _n); } void build(int oo, int l, int r) { if (l == r) { sum[oo] = lft[oo] = rht[oo] = ans[oo] = 0; return; } int m = (l + r) &gt;&gt; 1; build(lson, l, m); build(rson, m + 1, r); sum[oo] = lft[oo] = rht[oo] = ans[oo] = 0; } void update(int oo, int l, int r, int pos, ll val) { if (l == r &amp;&amp; r == pos) { sum[oo] += val;//+val? rht[oo] = max(0ll, sum[oo]); lft[oo] = max(0ll, sum[oo]); ans[oo] = max(0ll, sum[oo]); return; } int m = (l + r) &gt;&gt; 1; if (pos &lt;= m) update(lson, l, m, pos, val); else update(rson, m + 1, r, pos, val); lft[oo] = lft[lson]; rht[oo] = rht[rson]; sum[oo] = sum[lson] + sum[rson]; ans[oo] = max(ans[lson], ans[rson]); ans[oo] = max(ans[oo], rht[lson] + lft[rson]); lft[oo] = max(lft[oo], sum[lson] + lft[rson]); rht[oo] = max(rht[oo], rht[lson] + sum[rson]); if (lft[lson] == sum[lson]) ans[oo] = max(ans[oo], lft[lson] + lft[rson]); if (rht[rson] == sum[rson]) ans[oo] = max(ans[oo], rht[lson] + rht[rson]); } void update(int pos, ll val) { update(1, 1, n, pos, val); } ll query() { return ans[1]; }};SegTree tree;struct point { int x, y, v;} p[MAXN];int dsc[MAXN], dtot;void initDsc() { sort(dsc, dsc + dtot); dtot = unique(dsc, dsc + dtot) - dsc;}int getDsc(const int &amp;val) { return lower_bound(dsc, dsc + dtot, val) - dsc + 1;}int n;ll ans;int Kase;int xmax, ymax;int main() { ios_base::sync_with_stdio(0); cin.tie(0); cin &gt;&gt; Kase; while (Kase--) { ans = 0; dtot = 0; xmax = ymax = 0; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) { cin &gt;&gt; p[i].x &gt;&gt; p[i].y &gt;&gt; p[i].v; dsc[dtot++] = p[i].x; dsc[dtot++] = p[i].y; } initDsc(); for (int i = 1; i &lt;= n; ++i) { p[i].x = getDsc(p[i].x); p[i].y = getDsc(p[i].y); xmax = max(xmax, p[i].x); ymax = max(ymax, p[i].y); } sort(p + 1, p + 1 + n, [](const point &amp;a, const point &amp;b) { if (a.x == b.x)return a.y &lt; b.y; return a.x &lt; b.x; }); for (int l = 1; l &lt;= n; l++) { tree.init(ymax); for (int r = l; r &lt;= n; r++) { tree.update(p[r].y, p[r].v); if (p[r].x != p[r + 1].x) { ans = max(ans, tree.query()); } } while (p[l].x == p[l + 1].x)l++; } cout &lt;&lt; ans &lt;&lt; '\\n'; } return 0;}/*241 1 502 1 501 2 502 2 -5002-1 1 5-1 1 1 */","link":"/2019/08/08/CP/Solutions/hdu-6638-çº¿æ®µæ ‘-æœ€å¤§å­æ®µå’Œ/"},{"title":"contest-888-A å•è°ƒæ ˆ å‰ç¼€","text":"é¢˜æ„ç»™ä¸€ä¸ª01çŸ©é˜µï¼Œç„¶åæ±‚ä¸€ä¸ªçŸ©é˜µçš„æœ€å¤§å…¨1å­çŸ©é˜µæ•°é‡ï¼Œè¿™äº›çŸ©é˜µè¦ä¿è¯ï¼Œä¸è¢«å…¶ä»–å…¨ä¸€çŸ©é˜µåŒ…å«ã€‚ æ€è·¯ å®˜æ–¹é¢˜è§£è¯´çš„å¾ˆå¥½äº†ï¼Œè¡¥å……ï¼šæ ˆé‡Œå­˜çš„é«˜åº¦ä¼šè¦ä¹ˆå¤§äºå½“å‰upï¼Œè¦ä¹ˆç­‰äºå½“å‰upï¼Œæ˜¾ç„¶ç­‰äºçš„æ—¶å€™æ˜¯ä¸è®¡ç­”æ¡ˆçš„ï¼Œå¤§äºçš„æ—¶å€™éœ€è¦è®¡ç­”æ¡ˆï¼Œå¹¶ä¸”è¿™ä¸ªçŸ©å½¢çš„èŒƒå›´å…¶å®æ˜¯ä»æ˜¯å½“å‰æ˜¯ijå·¦è¾¹çš„ä½ç½®å¼€å§‹ã€‚ï¼ˆå¯èƒ½å’Œå†™æ³•æœ‰å…³ï¼‰ã€‚ è¿™æ ·çš„é¢˜ç›®æ²¡æœ‰æƒ³æ³•æ„Ÿè§‰éå¸¸å±é™©ã€‚ ä»£ç ç‰¹åˆ«åœ°ï¼Œæˆ‘æšä¸¾jåˆ°m+1å¯ä»¥çœä¸€æ¬¡æœ€åçš„é€€æ ˆä»£ç ã€‚ï¼ˆæ³¨é‡Šï¼‰ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;#define _debug(x) cerr&lt;&lt;#x&lt;&lt;\" = \"&lt;&lt;x&lt;&lt;endlusing namespace std;typedef long long ll;const int MAXN = 3e3 + 59;typedef long long ll;int n, m;struct { int up, ls;} stk[MAXN];int up[MAXN][MAXN]; //consecutive 1 above (i,j) (included)int pr[MAXN][MAXN]; //pre sum 1 in the left of (i,j) (included)char str[MAXN];int top;ll ans;int main() { ios_base::sync_with_stdio(0); cin.tie(0); ans = 0; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i) { cin &gt;&gt; (str + 1); for (int j = 1; j &lt;= m; ++j) { up[i][j] = (str[j] == '1') ? (up[i - 1][j] + 1) : 0; pr[i][j] = pr[i][j - 1] + (str[j] - '0'); } } for (int i = 1; i &lt;= n; ++i) { top = 0; for (int j = 1, k; j &lt;= m + 1; ++j) { k = j; while (top &amp;&amp; stk[top].up &gt;= up[i][j]) { k = stk[top].ls; if (stk[top].up &gt; up[i][j]) { int l = stk[top].ls; int r = j - 1; if (pr[i + 1][r] - pr[i + 1][l - 1] != r - l + 1) { ans++; } } top--; } if (up[i][j])stk[++top] = {up[i][j], k}; }// while (top) {// int l = stk[top].ls;// int r = m;// if (pr[i + 1][r] - pr[i + 1][l - 1] != r - l + 1) {// ans++;// }// top--;// } } cout &lt;&lt; ans &lt;&lt; endl; return 0;}","link":"/2019/08/11/CP/Solutions/contest-888-A-å•è°ƒæ ˆ-å‰ç¼€/"},{"title":"hdu-6698 Coins ä¼˜å…ˆé˜Ÿåˆ— dp","text":"é¢˜æ„ç»™nä¸ªæ•°å¯¹ï¼Œæ¯ä¸ªå¯¹å¯ä»¥å–ä¸¤æ¬¡ä»·å€¼ï¼Œç¬¬ä¸€æ¬¡å–å¾—å·¦è¾¹çš„aiï¼Œç¬¬äºŒæ¬¡æ‰å¯ä»¥å–å¾—å³è¾¹çš„biã€‚ ç°åœ¨è¦æ±‚è§£2nä¸ªé—®é¢˜ï¼Œé—®é¢˜iè¡¨ç¤ºè¾“å‡ºï¼Œå–iæ¬¡ä»·å€¼èƒ½è·å¾—çš„æœ€å¤§ä»·å€¼ã€‚ æ€è·¯æˆ‘ä»¬é›†è®­é˜Ÿçš„yyjå·¨å·¨æå‡ºäº†éå¸¸æ£’çš„çŒœæƒ³ã€‚æ€è€ƒçš„æ–¹å‘åº”è¯¥æ˜¯ï¼Œç”¨ä¼˜å…ˆé˜Ÿåˆ—ç»´æŠ¤å‰©ä½™çš„å¯¹ä¸­ï¼Œè¿˜èƒ½å–å¾—çš„æœ€å¤§ä»·å€¼ï¼Œå¯èƒ½ç¬¬ä¸€æ¬¡å–å·¦è¾¹çš„ï¼Œä¹Ÿå¯èƒ½æ˜¯ç¬¬äºŒæ¬¡å–å³è¾¹çš„ï¼Œç”±äºæ¯å¯¹æ•°éƒ½æ˜¯æœ€å¤šæœ‰åºå–ä¸¤æ¬¡ï¼Œæ¯æ¬¡ä»å‰ä¸€ä¸ªçŠ¶æ€è½¬ç§»ä¼šæœ‰æ¯”è¾ƒå¤šçš„è®¨è®ºï¼Œæ¯”å¦‚æŸä¸ªä½ç½®çš„å…ƒç´ æœ‰æ²¡æœ‰ä¹‹å‰è¢«å–è¿‡ï¼Œå–è¿‡å‡ æ¬¡ã€‚ï¼ˆå‚è€ƒæ ‡è§£ï¼‰ï¼ˆå¥½å§æˆ‘ä¸æ‡‚ï¼‰ é‚£ä¹ˆå‡å¦‚æˆ‘ä»¬æŠŠä¸¤æ­¥è½¬ç§»è¿èµ·æ¥çœ‹ï¼Œå¯ä»¥å½’çº³æˆä¸¤ç§è½¬ç§»ï¼Œå³å–äº†ä¸¤ä¸ªä¸åŒä½ç½®çš„å…ƒç´ aæˆ–bå„ä¸€æ¬¡ï¼Œæˆ–è€…è¿ç»­ä¸¤æ¬¡å–äº†ç›¸åŒä½ç½®çš„abå…ƒç´ ã€‚ å¯ä»¥å¤§æ¦‚æƒ³ä¸€ä¸‹æœ‰è¿™æ ·çš„è½¬ç§»ï¼š$$dp[i]=dp[i-2]+max(node[i].v+node[j].v, node[k].a+node[k].b)$$ æ³¨æ„ä¸Šå¼ä¸­ijkéƒ½ä»£è¡¨å‰©ä¸‹å¯è¡Œçš„ä½ç½®ä¸­çš„æœ€ä¼˜è§£ï¼Œä¹Ÿå°±æ˜¯ç”¨ä¼˜å…ˆé˜Ÿåˆ—è´ªå¿ƒçš„ã€‚ æ³¨æ„vä»£è¡¨aæˆ–è€…bï¼Œå› ä¸ºï¼Œæˆ‘ä»¬ä¹‹å‰å¯èƒ½å•ç‹¬å¯¹è¿™ä¸ªä½ç½®å–è¿‡å•æ¬¡çš„ï¼Œæ‰€ä»¥è¿™é‡Œéœ€è¦åšä¸€ç‚¹åˆ¤æ–­ã€‚ï¼ˆä½†å…¶å®å¾ˆç®€å•ï¼‰ æ³¨æ„åœ¨è¿™æ ·çš„è½¬ç§»ä¸‹ï¼Œå¥‡æ•°çš„ç­”æ¡ˆå’Œå¶æ•°çš„ç­”æ¡ˆå¯ä»¥ç‹¬ç«‹è½¬ç§»ã€‚dp[1]æ˜¾ç„¶æ˜¯æœ€å¤§çš„é‚£ä¸ªaã€‚ ä¸Šé¢çš„æƒ³æ³•ç•¥æ‡‚å³å¯ï¼Œå¦‚æœæ²¡æœ‰ç›´æ¥èƒ½è‡ªå·±æ•²å‡ºæ¥ä¹Ÿä¸è¦æ°”ï¼Œè¿™ä¸ªé¢˜ç¡®å®æ¯”è¾ƒéš¾æ•²ã€‚ ä¸‹é¢è®²ä¸€ä¸‹æˆ‘æ˜¯å¦‚ä½•å®ç°çš„ï¼Œæ„Ÿè°¢æˆ‘çš„é˜Ÿå‹LÃ¼cyå¸®æˆ‘ä¸€èµ·Debugã€‚ æ ¸å¿ƒåœ¨äºï¼Œä¸¤ä¸ªä¼˜å…ˆé˜Ÿåˆ—ç»´æŠ¤ï¼ˆæˆ–è€…è¯´å­˜å‚¨ï¼‰ï¼Œå‰©ä½™å¯å–çš„ä½ç½®æœ€å¤§çš„ä»·å€¼ä¸ä½ç½®ï¼Œè¿™é‡Œæˆ‘ç”¨äº†pairã€‚ æˆ‘ä»¬æœ‰ä¸¤ç§æ–¹æ¡ˆï¼Œä¸€ç§æ˜¯ä¸¤ä¸ªä¸åŒä½ç½®å„å–ä¸€æ¬¡ï¼Œä¸€ç§æ˜¯åŒä¸€ä¸ªä½ç½®å–ä¸¤æ¬¡ã€‚ ç¬¬ä¸€ä¸ªä¼˜å…ˆé˜Ÿåˆ—aå°±æ˜¯ä¸ºä¸åŒä½ç½®çš„æ–¹æ¡ˆæœåŠ¡çš„ã€‚ä½†æ˜¯ä¸ºäº†é˜²æ­¢å’Œå¦ä¸€ç§æ–¹æ¡ˆäº§ç”Ÿäº¤é›†ï¼Œæˆ‘åˆå§‹åŒ–åœ¨ä¼˜å…ˆé˜Ÿåˆ—é‡Œå¡æ‰€æœ‰çš„aï¼Œå½“æˆ‘ä½¿ç”¨æ‰æŸä¸ªaçš„æ—¶å€™ï¼Œå°±æŠŠbå‡çº§æˆaå†è¿˜å›åˆ°ä¼˜å…ˆé˜Ÿåˆ—é‡Œã€‚è¿™æ ·å°±ä¿è¯é˜Ÿåˆ—ä¸­æ‰€æœ‰æ–¹æ¡ˆéƒ½æ˜¯åœ¨ä¸åŒä½ç½®ä¸Šçš„ã€‚ ç¬¬äºŒä¸ªä¼˜å…ˆé˜Ÿåˆ—abä¸ä¸Šé¢ç±»ä¼¼ï¼Œä¸è¿‡å­˜çš„æ˜¯(ai+bi,i) ã€‚ ç„¶usedæ•°ç»„è®°å½•çš„æ˜¯ä½ç½®iè¢«ä½¿ç”¨çš„æ¬¡æ•°ï¼Œå› ä¸ºæˆ‘ä»¬ä¸¤ä¸ªé˜Ÿåˆ—å¾ˆéš¾ä¸€æ¬¡æ€§ä¿æŒç»Ÿä¸€åœ°åˆ å…ƒç´ ï¼Œé‚£ä¹ˆå¯ä»¥åœ¨å–å…ƒç´ åœ°æ—¶å€™åˆ¤æ‰ã€‚ å†é€€å›åˆ°ä¸»å‡½æ•°ï¼Œåº”è¯¥å®¹æ˜“å‘ç°å¥‡æ•°å¶æ•°çš„ç­”æ¡ˆå¯ä»¥åˆ†åˆ«è®¡ç®—ï¼Œåªæ˜¯èµ·ç‚¹ä¸åŒè€Œå·²ï¼Œæ³¨æ„è®¡ç®—å®Œans[1]ä¹‹åï¼Œä¹Ÿè¦æ¨¡æ‹Ÿä¸€æ¬¡å­˜å–å…ƒç´ çš„è¿‡ç¨‹ã€‚æˆ‘çš„æ“ä½œæ˜¯ï¼Œå¹²è„†ä¸€å¼€å§‹å°±æŠŠå¯¹åº”ä½ç½®çš„ï¼Œusedæ›´æ–°äº†ï¼Œä¹ŸæŠŠåˆå§‹çš„aå˜æˆbï¼Œè¿™æ ·å¯ä»¥å¤ç”¨åŒæ ·çš„ä»£ç ã€‚ å¯èƒ½ä¸­é—´æœ‰ä¸€äº›å¥‡æ€ªçš„æ“ä½œï¼Œè§è°…ã€‚ ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#define _debug(x) cerr&lt;&lt;#x&lt;&lt;\" = \"&lt;&lt;x&lt;&lt;endlusing namespace std;typedef long long ll;const int MAXN = 1e5 + 5;const int INF = 0x3f3f3f3f;const ll MOD = 1e9 + 7;typedef long long ll;typedef pair&lt;int, int&gt; node;int n, q;int kase;node a[MAXN];node ab[MAXN];short used[MAXN];int ans[MAXN &lt;&lt; 1];void solv(int i) { //æ•°ç»„è½¬ä¼˜å…ˆé˜Ÿåˆ—ã€‚ priority_queue&lt;node&gt; qa(a, a + n); priority_queue&lt;node&gt; qab(ab, ab + n); for (int x, xi, y, yi, z, zi; i &lt;= 2 * n; i += 2) { ans[i] = ans[i - 2]; z = x = y = -1; zi = xi = yi = -1; while (!qa.empty() &amp;&amp; used[qa.top().second] &gt;= 2)qa.pop(); if (!qa.empty() &amp;&amp; qa.size() &gt;= 2) { x = qa.top().first; xi = qa.top().second; qa.pop(); while (!qa.empty() &amp;&amp; used[qa.top().second] &gt;= 2)qa.pop(); if (!qa.empty()) { y = qa.top().first; yi = qa.top().second; qa.pop(); } else { qa.emplace(x, xi); x = xi = -1; } } while (!qab.empty() &amp;&amp; used[qab.top().second] &gt; 0)qab.pop(); if (!qab.empty()) { z = qab.top().first; zi = qab.top().second; qab.pop(); } if (x + y &gt; z) { ans[i] += x + y; used[xi]++; used[yi]++; if (used[xi] == 1)qa.emplace(ab[xi].first - x, xi); if (used[yi] == 1)qa.emplace(ab[yi].first - y, yi); if (z != -1)qab.emplace(z, zi); } else { ans[i] += z; used[zi] += 2; if (x != -1)qa.emplace(x, xi); if (y != -1)qa.emplace(y, yi);// if (z != -1)qa.emplace(z - a[zi].first, zi); } }}int main() { scanf(\"%d\", &amp;kase); while (kase--) { scanf(\"%d\", &amp;n); int maxx = 0, maxi = 0; for (int x, y, i = 0; i &lt; n; i++) { scanf(\"%d%d\", &amp;x, &amp;y); if (x &gt; maxx) { maxx = x; maxi = i; } a[i] = {x, i}; ab[i] = {x + y, i}; } for (int i = 0; i &lt; n; ++i)used[i] = 0; solv(2); for (int i = 0; i &lt; n; ++i)used[i] = 0; ans[1] = maxx; a[maxi].first = ab[maxi].first - a[maxi].first; used[maxi] = 1; solv(3); for (int i = 1; i &lt;= 2 * n; ++i) printf(\"%d%c\", ans[i], \" \\n\"[i == n + n]); } return 0;}","link":"/2019/08/21/CP/Solutions/hdu-6698-Coins-ä¼˜å…ˆé˜Ÿåˆ—-dp/"},{"title":"2019.8.8 ç‰›å®¢å¤šæ ¡ç¬¬ä¸ƒåœº","text":"2019ç‰›å®¢æš‘æœŸå¤šæ ¡è®­ç»ƒè¥ï¼ˆç¬¬ä¸ƒåœºï¼‰ é¢˜å· æ ‡é¢˜ é€šè¿‡ç‡ dsc stt A String 691/3864 æš´åŠ›/æƒ³æ³• âˆš- B Irreducible Polynomial 792/2431 ç»“è®º âˆš- C Governing sand 520/2702 çº¿æ®µæ ‘ âˆš- D Number 985/1499 ç­¾åˆ° âˆš- E Find the median 138/1261 F Energy stones 20/149 G Make Shan Happy 3/29 H Pair 143/343 æ•°ä½DP I Chessboard 34/129 J A+B problem 1061/1919 ç­¾åˆ° âˆš- K Function 17/64 â—‹ ä»£è¡¨èµ›åè¡¥é¢˜ âˆš+ ä»£è¡¨èµ›å†…æˆ‘é€šè¿‡çš„ âˆš- ä»£è¡¨èµ›å†…ä¸æ˜¯æˆ‘åšçš„ âˆš-â—‹ä»£è¡¨èµ›å†…ä¸æ˜¯æˆ‘åšçš„ï¼Œè¡¥äº† A (520/3277) B (682/2135) C (348/1829) D (947/1447) E (74/842) F (14/97) F (14/97) G (2/27) H (83/204) I (16/71) J (997/1793) K (7/40) 01:56:17(-8) 00:36:55 03:14:32 00:09:09 00:04:42 Aé¢˜æ„æ„Ÿè§‰å¯ä»¥å˜æˆä¸€ä¸ªå¾ˆéš¾å¾—é¢˜ã€‚ è™½ç„¶è¯´æš´åŠ›å°±å¯ä»¥ï¼Œä½†æˆ‘ä¸æ˜¯å¾ˆæ‡‚æ¬¸= =ã€‚ Bé¢˜æ„æ˜¯ç»™ä¸€ä¸ªå¤šé¡¹å¼ï¼Œåˆ¤æ–­å¤šé¡¹å¼æ˜¯å¦è¿˜èƒ½å› å¼åˆ†è§£ã€‚ æœ‰ä¸€ä¸ªç»“è®ºæ˜¯ï¼Œå°‘äºä¸‰é¡¹è‚¯å®šä¸è¡Œï¼Œå¤šäºä¸‰é¡¹å¿…å®šå¯ä»¥ã€‚ åˆ¤æ–­ä¸€ä¸‹ä¸‰é¡¹å¾—æƒ…å†µå°±å¥½äº†ï¼ˆå¯¹äºn=2ï¼‰ï¼› Cç»™nç§æ ‘ï¼Œæ¯ç§æ ‘æœ‰é«˜åº¦ï¼ŒèŠ±è´¹ï¼Œæ•°é‡ä¸‰ä¸ªå±æ€§ï¼Œç°åœ¨è¦æ±‚ç æ‰ä¸€äº›æ ‘ï¼Œä½¿å¾—å‰©ä¸‹å¾—æ ‘æœ€é«˜çš„ä¸¥æ ¼å¤§äºå‰©ä½™æ ‘çš„æ€»æ•°çš„ä¸€åŠã€‚æ±‚æœ€å°èŠ±è´¹ã€‚ æ³¨æ„ï¼Œå…è®¸å¤šç§æ ‘çš„é«˜åº¦ç›¸ç­‰ã€‚ è™½ç„¶ä¸æ˜¯æˆ‘åšçš„ï¼Œä½†æ˜¯å’Œé˜Ÿå‹å¤§æ¦‚çš„æ€è·¯æ˜¯è¿™æ ·çš„ï¼Œä»é«˜åˆ°ä½æšä¸¾é«˜åº¦ï¼Œè¿™ä¸ªé«˜åº¦ä½œä¸ºæœ€åå‰©ä¸‹æ ‘çš„æœ€é«˜é«˜åº¦ï¼Œæ¯æ¬¡åˆ æ‰æ¯”è¿™ä¸ªé«˜åº¦é«˜çš„æ ‘çš„æ€»èŠ±è´¹ï¼Œå†å»æŸ¥è¯¢ä½™ä¸‹çš„æ ‘è¿˜éœ€è¦åˆ å»çš„å‰mæ£µæœ€å°çš„èŠ±è´¹å’Œã€‚ è¿™ä¸ªå¯ä»¥ç”¨çº¿æ®µæ ‘ç»´æŠ¤ä¸€ä¸‹ï¼Œä½†æ˜¯è¿˜æ²¡æƒ³é€šã€‚ Dç»™äº†nå’Œp, éœ€è¦è¾“å‡ºä¸€ä¸ªæ•°ï¼Œåˆšå¥½æœ‰nä½æ•°è€Œä¸”æ•´é™¤p. æ€è·¯æ˜¯ç›´æ¥å†påé¢å¡«0å³å¯ã€‚","link":"/2019/08/08/CP/Logs/2019-8-8-ç‰›å®¢å¤šæ ¡ç¬¬ä¸ƒåœº/"},{"title":"hdu-6685 Rikka with Coin è´ªå¿ƒ æƒ³æ³•","text":"http://acm.hdu.edu.cn/showproblem.php?pid=6685 é¢˜æ„ç»™ä¸€ä¸ªä¸è¶…è¿‡100çš„æ•°ç»„ï¼Œæ¯ä¸ªå…ƒç´ ä»£è¡¨ä»·æ ¼ï¼Œéœ€è¦æœ€å°‘æºå¸¦å¤šå°‘ä¸ªï¼Œ10/20/50/100é¢é¢çš„ç¡¬å¸ï¼Œå¯ä»¥è´­ä¹°ä»»æ„ä¸€ä¸ªç‰©å“ã€‚ æ€è·¯çªç ´å£æ˜¯ï¼Œ10é¢é¢åˆ°10ä¸ªï¼Œ20é¢é¢åˆ°5ä¸ªï¼Œ50é¢é¢åˆ°2ä¸ªï¼Œï¼ˆå› ä¸ºä¸€æ—¦è¶…è¿‡å°±å¯ä»¥ç”¨100é¢é¢æ›¿ä»£æ›´ä¼˜ï¼‰ï¼Œå¥½åƒå¦‚æœæšä¸¾å°é¢é¢ï¼Œå°±å¤§æ¦‚èƒ½çŸ¥é“100é¢é¢çš„æœ‰å¤šå°‘ä¸ªäº†ï¼Œæšä¸¾æ¬¡æ•°ä¹Ÿæ‰100çš„å¤æ‚åº¦ï¼Œé‚£å°±ä¸‰å±‚foræšä¸¾å§ã€‚ ç„¶åæ€ä¹ˆç®—100æœ‰å¤šå°‘ä¸ªï¼Œæˆ‘æ˜¯è¿™æ ·åšçš„ï¼Œ æœ¬èº«å†ä¸‰å±‚foræšä¸¾ä¸€ä¸‹ï¼Œæ˜¯ä¸æ˜¯å½“å‰çš„ç¡¬å¸å¯ä»¥å‡‘å‡ºå½“å‰çš„aiï¼Œå¦‚æœaiæ¯”è¾ƒå¤§ï¼Œå¯ä»¥iè¯•ç€å»æ‰ä¸€äº›100å»æ£€æŸ¥ã€‚æˆ‘ä»¬æšä¸¾çš„é¢é¢æœ€å¤šæ˜¯220ï¼Œæ‰€ä»¥å…ˆé™åˆ°åˆ°200+ai%100æ£€æŸ¥ä¸€ä¸‹ï¼Œç„¶åå†é™åˆ°100+ai%100æ£€æŸ¥ä¸€ä¸‹ï¼Œå°±å¯ä»¥äº†ã€‚ ä»£ç 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;bits/stdc++.h&gt;//#include &lt;stdio.h&gt;//#include &lt;algorithm&gt;#define per(i, a, b) for(int i=(a);i&lt;=b;i++)#define _debug(x) cerr&lt;&lt;#x&lt;&lt;\" = \"&lt;&lt;x&lt;&lt;endlusing namespace std;typedef long long ll;const int MAXN = 1e5 + 59;const ll MOD = 1e9 + 7;const ll INF = 1e9 + 59;int kase, n, ans;int a[105];int b[105];bool chek(int x, int i, int j, int k) { //10 20 50; per(_10, 0, i) per(_20, 0, j) per(_50, 0, k) if (_10 * 10 + _20 * 20 + _50 * 50 == x) return true; return false;}int main() { ios_base::sync_with_stdio(0); cin.tie(0); cin &gt;&gt; kase; while (kase--) { ans = INF; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i]; per(_10, 0, 10) per(_20, 0, 5) per(_50, 0, 2) { int _100 = 0; bool valid = true; for (int i = 1; valid &amp;&amp; i &lt;= n; ++i) { if (chek(a[i], _10, _20, _50)) { _100 = max(_100, 0); } else if (a[i] &gt;= 300 &amp;&amp; chek(a[i] % 100 + 200, _10, _20, _50)) { _100 = max(_100, a[i] / 100 - 2); } else if (a[i] &gt;= 200 &amp;&amp; chek(a[i] % 100 + 100, _10, _20, _50)) { _100 = max(_100, a[i] / 100 - 1); } else if (a[i] &gt;= 100 &amp;&amp; chek(a[i] % 100, _10, _20, _50)) { _100 = max(_100, a[i] / 100); } else { valid = false; } } if (valid) ans = min(ans, _10 + _20 + _50 + _100); } if (ans == INF)ans = -1; cout &lt;&lt; ans &lt;&lt; endl; } return 0;}/* */","link":"/2019/08/19/CP/Solutions/hdu-6685-Rikka-with-Coin-è´ªå¿ƒ-æƒ³æ³•/"},{"title":"2019-9-18 2019 ICPC UNdC","text":"Name AC Amazon Boring Non-Palindrome âˆš- Common Subsequence âˆš- Do Not Try This Problem Extreme Image Fraction Formula Graduation âˆš- Hardest Challenge Integer Prefix âˆš+ Jail Destruction Kernel Of Love âˆš- Liquid X â—‹ ä»£è¡¨èµ›åè¡¥é¢˜ âˆš+ ä»£è¡¨èµ›å†…æˆ‘é€šè¿‡çš„ âˆš- ä»£è¡¨èµ›å†…ä¸æ˜¯æˆ‘åšçš„ âˆš-â—‹ä»£è¡¨èµ›å†…ä¸æ˜¯æˆ‘åšçš„ï¼Œè¡¥äº† å°ç»“ åšFæ„è¯†åˆ°äº†å­¦pythonçš„å¿«ä¹ï¼ˆç„¶è€Œä¸ä¼š ä¸­é—´è¯»é”™é¢˜æœ‰ç‚¹ä¼¤ pythonçš„Fractionä¸å¥½ç”¨ L. Integer Prefixè¾“å‡ºæœ€é•¿çš„çº¯æ•°å­—å‰ç¼€ã€‚ 1234567891011121314151617181920#include &lt;bits/stdc++.h&gt; using namespace std; int main() { int T; scanf(\"%d\", &amp;T); while (T--) { int n; scanf(\"%d\", &amp;n); if (n &lt; 3) { printf(\"0\\n\"); continue; } int ans = n / 3 * 2; if (n % 3)ans++; printf(\"%d\\n\", ans); } return 0;} B. Boring Non-Palindromebncç¨å¾®è¯»é”™äº†ï¼Œæ„æ€æ˜¯åœ¨ä¸²çš„æœ«å°¾æ·»åŠ æœ€å°‘çš„å…ƒç´ ï¼Œä½¿å¾—ä¸²å˜æˆå›æ–‡ä¸²ã€‚ æˆ‘ä»¬çš„åšæ³•æ˜¯ï¼Œåšä¸€ä¸‹Manacherï¼Œæ‰¾åˆ°æœ€é•¿çš„åç¼€å›æ–‡ä¸²ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std; const int N=5005; char ss[N&lt;&lt;2];int p[N&lt;&lt;2]; void manacher(char *s){ int len=strlen(s); for(int i=len;i&gt;=0;--i){ s[i+i+2]=s[i]; s[i+i+1]='#'; } s[0]='*'; int k=1,maxlen=0; for(int i=2;i&lt;len+len+1;++i){ int maxr=k+p[k]-1; p[i]=min(p[2*k-i],max(maxr-i+1,1)); while(s[i-p[i]] == s[i+p[i]])++p[i]; if(i+p[i]&gt;k+p[k])k=i; if(p[i]&gt;maxlen)maxlen=p[i]; }} map&lt;int,string&gt;mp; int main(){ scanf(\"%s\",ss); int len=strlen(ss); manacher(ss); int ed=len*2+1; int pos=0; for(int i=1;i&lt;=ed;i++){ if(p[i]+i-1==ed){ pos=i; break; } } for(int i=1;i&lt;=pos;i++){ if(!(i&amp;1)){ printf(\"%c\",ss[i]); } } for(int i=pos-1;i&gt;1;i--){ if(!(i&amp;1)){ printf(\"%c\",ss[i]); } } printf(\"\\n\"); return 0;} K. Kernel Of Loveæ±‚ä¸€ä¸ªå‰nä¸ªæ–æ³¢é‚£å¥‘æ•°ï¼Œæœ‰å¤šå°‘å¯¹æ»¡è¶³å››ä¸ªæ¡ä»¶çš„ã€‚å¯ä»¥å¤§èƒ†æƒ³ä¸€äº›ä¼—æ‰€å‘¨çŸ¥çš„ç»“è®ºã€‚ 1234567891011121314151617181920#include &lt;bits/stdc++.h&gt; using namespace std; int main() { int T; scanf(\"%d\", &amp;T); while (T--) { int n; scanf(\"%d\", &amp;n); if (n &lt; 3) { printf(\"0\\n\"); continue; } int ans = n / 3 * 2; if (n % 3)ans++; printf(\"%d\\n\", ans); } return 0;} G. Graduationç»™né—¨è¯¾çš„å…ˆåå…³ç³»ï¼Œä»¥åŠä¸€ä¸ªå­¦æœŸèƒ½ä¸Šçš„è¯¾kï¼Œæ±‚æœ€å°‘éœ€è¦å‡ ä¸ªå­¦æœŸæ‰èƒ½ä¸Šå®Œè¯¾ã€‚ ä¸€ä¸ªè¯¾åªæœ‰ä¸€ä¸ªå‰é©±ï¼Œå¹¶ä¸”å¿…é¡»æ˜¯è¦ä¸Šè¿‡ä»¥åæ‰èƒ½é€‰ã€‚ æ€è·¯ï¼š å…¶å®æ˜¯è´ªå¿ƒé¢˜ï¼ŒæŠŠå…ˆåå…³ç³»è¿æˆä¸€æ£µæ ‘ï¼Œä¼˜å…ˆä¸Šæ‰â€œæ·±åº¦è¾ƒå¤§â€çš„è¯¾å³å¯ã€‚ å¯ä»¥è¿™æ ·ç†è§£ï¼Œå¦‚æœå…³ç³»é“¾è¶Šé•¿ï¼Œå¦‚æœä¸æ—©ç‚¹ä¸Šï¼Œå°±å¯èƒ½æŠŠä¸€ä¸ªå­¦æœŸçš„kä¸ªæ¬¡æ•°ç”¨å®Œï¼Œå°±ä¼šæ›´å¯èƒ½æŠŠå¾ˆå¤šè¯¾å»¶åï¼Œè¿™å°±ä¸ä¼˜äº†ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;bits/stdc++.h&gt;using namespace std;const int N=1e4+4;int n,k; int a[N];int dep[N]; int head[N],cnt;struct _edge{ int v,nxt;}edge[N]; void add_edge(int u,int v){ edge[++cnt].v=v; edge[cnt].nxt=head[u]; head[u]=cnt;} struct node{ int dep,id; bool operator &lt;(const node &amp;a)const { return dep&lt;a.dep; }}p[N]; priority_queue&lt;node&gt;q; void dfs(int u,int fa){ dep[u]=0; for(int i=head[u];~i;i=edge[i].nxt){ int v=edge[i].v; if(v==fa)continue; dfs(v,u); dep[u]=max(dep[u],dep[v]+1); }} bool vis[N];int st[N],top;int main(){ scanf(\"%d%d\",&amp;n,&amp;k); memset(head,-1, sizeof(head)); for(int i=1;i&lt;=n;i++){ scanf(\"%d\",&amp;a[i]); add_edge(a[i],i); } dfs(0,-1); for(int i=0;i&lt;=n;i++){ p[i]={dep[i],i}; } q.push(p[0]); vis[0]= true; int dfn=-1; while (true){ dfn++; top=0; for(int i=1;i&lt;=k&amp;&amp;!q.empty();i++){ st[++top]=q.top().id; q.pop(); } if(!top){ break; } for(int i=1;i&lt;=top;i++){ for(int j=head[st[i]];~j;j=edge[j].nxt){ int v=edge[j].v; if(vis[v])continue; q.push({dep[v],v}); vis[v]=true; } } if(q.empty()){ break; } } printf(\"%d\\n\",dfn); return 0;} D. Do Not Try This Problemè¿™é¢˜æ¯”è¾ƒæœ‰ä¸œè¥¿ã€‚ ç»™ä¸¤ä¸ªä¸²ï¼Œæé—®ä¸¤ä¸ªä¸²ä¹‹é—´çš„æœ€å¤§å…¬å…±å­åºåˆ—æ˜¯å¦å¤§äºç­‰äº$0.99N$ã€‚ å­—ç¬¦é›†åªæœ‰4ã€‚ ä¼¼ä¹æ˜¯åˆ©ç”¨å­—ç¬¦é›†å’Œ0.99ä¼˜åŒ–ä¸€ä¸ª$O(N^2)$çš„åšæ³•ï¼Œæˆ‘ä¸å¤ªä¼šÂ·Â·Â· å¯ä»¥å…ˆæƒ³è±¡æœ€é•¿å…¬å…±å­åºåˆ—çš„dpï¼Œç„¶åå»ä¼˜åŒ–å®ƒã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt; using namespace std;const int maxn = 1e5 + 5;int dp[2][2005];char a[maxn];char b[maxn];int app[maxn][26]; int getval(int z, int i, int j) { int k = j - i + 1000; return dp[z][k];} void setval(int z, int i, int j, int v) { int k = j - i + 1000; dp[z][k] = v;} int main() { scanf(\"%s%s\", a + 1, b + 1); int n = strlen(a + 1); for (int i = 1; i &lt;= n; i++) { for (int j = 0; j &lt; 26; j++) { app[i][j] = app[i - 1][j]; } app[i][b[i] - 'A'] = i; } int lim = n / 100; int now = 0; int last = 1; int ans; for (int i = 1; i &lt;= n; i++) { now ^= 1; last ^= 1; int l = max(i - lim, 1); int r = min(i + lim, n); int id = a[i] - 'A'; for (int j = l; j &lt;= r; j++) { int temp; if (j == i + lim)temp = getval(last, i - 1, j - 1); else temp = getval(last, i - 1, j); int p = app[j][id]; if (p &gt;= l &amp;&amp; p &lt;= r)temp = max(temp, getval(last, i - 1, p - 1)+1); if (j &lt;= i - lim + 1)setval(now, i, j, temp); else if (j == l)setval(now, i, j, temp); else setval(now, i, j, max(temp, getval(now, i, j - 1))); } if (i == n)ans = max(getval(now, i, l), getval(now, i, r)); } //printf(\"%d\\n\",ans); if(ans*100&gt;=n*99)printf(\"Long lost brothers D:\"); else printf(\"Not brothers :(\"); return 0;}","link":"/2019/09/18/CP/Logs/2019-09-18-2019-ICPC-UNdC/"},{"title":"2019.8.12 æ­ç”µå¤šæ ¡ç¬¬ä¸ƒåœº","text":"# name AC dsc stt 6646 A + B = C 23.67%(125/528) æƒ³æ³•/å¤§æ•°/å­—ç¬¦ä¸² 6647 Bracket Sequences on Tree 18.60%(8/43) 6648 Cuber Occurrence 22.22%(2/9) 6649 Data Structure Problem 25.00%(3/12) 6650 Equation 11.11%(1/9) 6651 Final Exam 47.09%(421/894) æƒ³æ³•/ç»“è®º âˆš+ 6652 Getting Your Money Back 16.82%(18/107) 6653 Halt Hater 30.09%(34/113) 6654 Intersection of Prisms 0.00%(0/6) 6655 Just Repeat 18.23%(128/702) 6656 Kejin Player 38.95%(201/516) æ¦‚ç‡ âˆš+ â—‹ ä»£è¡¨èµ›åè¡¥é¢˜ âˆš+ ä»£è¡¨èµ›å†…æˆ‘é€šè¿‡çš„ âˆš- ä»£è¡¨èµ›å†…ä¸æ˜¯æˆ‘åšçš„ âˆš-â—‹ä»£è¡¨èµ›å†…ä¸æ˜¯æˆ‘åšçš„ï¼Œè¡¥äº† Kejin Playerå¾ˆåº†å¹¸è‡ªå·±è¿‡äº†ã€‚ç¬¬ä¸€æ¬¡è‡ªå·±æ¨å‡ºæ¦‚ç‡è®¡ç®—é¢˜ã€‚ é—®é¢˜æ˜¯ä»içº§å‡åˆ°i+1çº§æœ‰ä¸€ä¸ªèŠ±è´¹aiï¼Œä½†æ˜¯æœ‰ä¸€ä¸ªæ¦‚ç‡piï¼Œä»£è¡¨æˆåŠŸç‡ã€‚å¦‚æœå¤±è´¥äº†ï¼Œå°±ä¼šæ‰åˆ°ç™»è®°riã€‚ ç°åœ¨å¤šæ¬¡è¯¢é—®låˆ°rç­‰çº§çš„å‡çº§èŠ±è´¹ã€‚ ä»iåˆ°i+1å…¶å®æ˜¯ä¸€ä¸ªå‡ ä½•æ¦‚å‹ï¼Œæ¯æ¬¡è¯•éªŒçš„æˆåŠŸç‡æ˜¯piï¼Œé‚£ä¹ˆé‡å¤è¯•éªŒåˆ°ç¬¬ä¸€æ¬¡æˆåŠŸçš„æœŸæœ›å¯ä»¥çŸ¥é“æ˜¯$\\frac{1}{pi} $è¿™ä¸ªé—®é¢˜å¯ä»¥å»ä¸“é—¨å­¦ä¸€ä¸‹å‡ ä½•æ¦‚å‹ã€‚ å¯ä»¥è¯´å¹³å‡èŠ±äº†$\\frac{1}{pi} $æ¬¡æ‰å‡çº§ï¼Œé‚£ä¹ˆ$\\frac{1}{pi}-1 $å°±æ˜¯é™çº§çš„æ¬¡æ•°ï¼Œé™çº§çš„æ¬¡æ•°å†ä¹˜ä¸Šä»riå‡åˆ°içš„èŠ±è´¹å°±æ˜¯å¹³å‡å‡çº§å¤±è´¥ä»¥åè¡¥æ•‘çš„èŠ±è´¹ï¼Œè¡¥æ•‘+aiå°±æ˜¯ä»iå‡åˆ°i+1çš„èŠ±è´¹ã€‚ è®¡ç®—å‡ºiåˆ°i+1çš„ã€‚","link":"/2019/08/12/CP/Logs/2019-8-12-æ­ç”µå¤šæ ¡ç¬¬ä¸ƒåœº/"},{"title":"map","text":"index &gt; STL &gt; map ç»†è‡´çš„ä»‹ç»è¿˜æ˜¯å‰äººåšçš„å¥½ï¼Œæˆ‘è‡ªæ„§ä¸å¦‚ã€‚ https://blog.csdn.net/fhb1922702569/article/details/80984774 https://blog.csdn.net/sevenjoin/article/details/81943864 å…³äºæ¯”è¾ƒ åˆ—å‡ ç‚¹æˆ‘å¸¸å¿½è§†çš„ç»†èŠ‚ï¼š ç”¨mp.insert()å‡½æ•°æ’å…¥å·²æœ‰keyçš„æ•°æ®æ—¶ï¼Œä¸èƒ½æ’å…¥æ•°æ®ã€‚è€Œmp[key]å¼•ç”¨å¯æ”¹å†™keyå¯¹åº”çš„valueã€‚ mapå…§éƒ¨çš„å®ç°è‡ªå»ºä¸€é¢—çº¢é»‘æ ‘ï¼Œè¿™é¢—æ ‘å…·æœ‰å¯¹æ•°æ®è‡ªåŠ¨æ’åºçš„åŠŸèƒ½ã€‚ï¼ˆé¢è¯•å¯èƒ½ä¹Ÿä¼šè§åˆ°ç›¸å…³çš„æé—®ï¼‰ éƒ¨åˆ†åº”ç”¨ç¦»æ•£åŒ–å•çº¯åˆ©ç”¨ä¸€ä¸€å¯¹åº”çš„ç‰¹æ€§ã€‚ æ‰“æ ‡è®°è™½ç„¶è¯´ç”¨ [] å¾ˆæ–¹ä¾¿ï¼Œä½†æ˜¯å¦‚æœå°±æ˜¯äºŒå…ƒçš„æ ‡è®°ï¼Œè¿˜æ˜¯å·§ç”¨insert/erase/find/count æ¯”è¾ƒç¨³å¦¥ã€‚ï¼ˆåŸå› æœ‰å¾…è§£é‡Šï¼Œå¯èƒ½æ‰“è„¸ï¼‰ ç‰¹æ®ŠäºŒå‰æœç´¢æ ‘ï¼ˆç±»çº¢é»‘æ ‘ï¼‰ â€”â€”â€œä½ å…¶å®æœ‰ä¸€æ£µéšå«éšåˆ°çš„çº¢é»‘æ ‘ã€‚â€ é¡»çŸ¥ï¼š mapæ˜¯æœ‰åºå®¹å™¨ã€‚ mp.begin() å¯è®¿é—®ç¬¬ä¸€ä¸ªé”®å€¼å¯¹ï¼ˆæœ€å€¼ï¼‰ã€‚ mp[key] ä¿®æ”¹æŸä¸ªkeyçš„æƒå€¼ï¼Œè€Œä¸”æ”¹å®Œä¿æŒæœ‰åºã€‚ mp.insert() mp.erase() mp.find() å¢åˆ æ”¹æŸ¥éƒ½æœ‰ã€‚ ç”šè‡³è¿˜èƒ½è‡ªè¡Œ mp.lower_bound() mp.upper_bound() é»˜è®¤lesser&lt;int&gt;å‡åºï¼Œæƒ³è¦é™åºä¹Ÿå¯ä»¥ï¼ˆå¦‚æœä¸æ˜¯åŸç”Ÿç±»å‹å¾—å¦å¤–å†™æ¯”è¾ƒç±»ï¼‰ï¼š 1map&lt;int, int, greater&lt;int&gt; &gt; cnts; æœ‰äº†ä¸Šé¢è¿™äº›é¢†æ‚Ÿï¼Œä½ è¿™å¯ä»¥è§£å†³æŸäº›ç‰¹å®šçš„æƒ…å†µï¼š æ¯”å¦‚æœ‰ä¸€ç¾¤äººï¼Œæ¯ä¸ªäººçš„åˆ†æ•°ä¸åŒï¼Œæ‰¾ä¸€ä¸‹æœ€é«˜åˆ†çš„äººæœ‰å‡ ä¸ªã€‚ æˆ–è€…ï¼Œè¦è¾“å‡ºï¼Œç¬¬ä¸€/ç¬¬äºŒ/ç¬¬ä¸‰çš„åˆ†æ•°ï¼Œå’Œå¯¹åº”çš„äººæ•°ã€‚ å¦‚æœå«Œç®€å•ï¼Œå†éš¾ä¸€ç‚¹ï¼Œä¿®æ”¹mæ¬¡åˆ†æ•°ï¼Œæ¯æ¬¡ä¿®æ”¹å°±å†æ±‚ä¸€æ¬¡ç­”æ¡ˆã€‚ 1e6çš„äººæ•°ï¼Œ1e9çš„åˆ†æ•°ï¼Œå¯æœ‰è´Ÿåˆ†ï¼Œä¿®æ”¹/è¯¢é—®1e6ã€‚ å¯èƒ½ä»¥ä¸Šè¿™ä¸ªé¢˜ç›®æ¯”è¾ƒæ‹™åŠ£ï¼Œå¦‚æœä»¥åæœ‰æ›´å¥½çš„ä¼šå†æ”¾è¿›æ¥ã€‚ç®€å•åœ°è¯´ï¼Œå……åˆ†åˆ©ç”¨keyæ’åºå’Œä¿®æ”¹æ–¹ä¾¿çš„ç‰¹æ€§ã€‚","link":"/2019/09/16/CP/C++/map/"},{"title":"jsk-41402 ICPC Shenyang Pre E","text":"é¢˜æ„link ç»™ä¸€ä¸ªå›¾ï¼Œæœ‰äº›ç‚¹æ˜¯åçš„ï¼Œæœ‰äº›ç‚¹æ˜¯å¥½çš„ã€‚ä¸»è§’è‡ªç”±è¡ŒåŠ¨ï¼Œä½†ä¼šæœ‰æ„è¯†åœ°å°½é‡èµ°å¤šçš„å¥½ç‚¹ã€‚ æ¯ä¸ªå¥½ç‚¹å¯ä»¥å–èµ°ä¸€ä¸ªæ”¶ç›Šï¼Œç¬¬ä¸€æ¬¡è®¿é—®åˆ°åç‚¹ï¼Œä¼šç­‰æ¦‚ç‡è·³åˆ°ä¸ä¹‹ç›¸é‚»çš„æŸä¸€ç‚¹ã€‚ æ³¨æ„ç¬¬äºŒæ¬¡èµ°åˆ°åç‚¹å°±ç›´æ¥ç»“æŸè¿‡ç¨‹ï¼Œæˆ–è€…æ²¡æœ‰æ›´å¤šæ”¶ç›Šçš„æ—¶å€™ï¼Œå¯ä»¥ä¸»åŠ¨ç»“æŸè¿‡ç¨‹ã€‚ èµ·ç‚¹æ˜¯1ï¼Œæ±‚æ”¶ç›Šçš„æœŸæœ›ã€‚ æ€è·¯ç›¸äº’è¿é€šçš„å¥½ç‚¹å¿…ç„¶å¯ä»¥ç¼©æˆä¸€å—ã€‚å½“ç¼©æˆä¸€å—çš„æ—¶å€™ï¼Œç¬¬ä¸€å—çš„æ”¶ç›Šå¿…å®šå–å®Œã€‚ è€Œäººåªèƒ½èµ°ä¸€æ¬¡åç‚¹ï¼Œæœ‰äº›é€‰æ‹©æ˜¯æ›´ä¼˜çš„ï¼ˆæœŸæœ›æ›´å¤§ï¼‰ï¼Œæ‰€ä»¥æœ‰æ„è¯†çš„ä¸»è§’åªä¼šèµ°æœŸæœ›æœ€å¤§çš„æ–¹æ¡ˆã€‚ï¼ˆå¦‚æœæœ‰å¤šä¸ªæœŸæœ›ç›¸ç­‰çš„æƒ…å†µï¼Œå…¶å®ä»”ç»†ä¸€æƒ³ï¼Œç­‰æ¦‚ç‡å»èµ°çš„æ—¶å€™ï¼Œæ”¶ç›Šçš„æœŸæœ›æ˜¯ä¸€æ ·çš„ï¼Œæ‰€ä»¥åªè¦çŸ¥é“æœ€å¤§æ˜¯å¤šå°‘å³å¯ï¼‰ æœ‰äº†ä»¥ä¸Šçš„ç†è§£ï¼Œåªè¦çŸ¥é“æ€ä¹ˆç®—ç¬¬ä¸€ä¸ªèµ°åˆ°çš„ç‚¹çš„æœŸæœ›æ€ä¹ˆç®—å°±å¥½äº†ã€‚æ— éå°±æ˜¯æ‰€é“¾æ¥å—çš„æ”¶ç›Šæ±‚å’Œä¹˜ä»¥æ¦‚ç‡å³å¯ã€‚ æœ‰äº›ç»†èŠ‚ï¼š èµ·ç‚¹æ‰€åœ¨çš„å—çš„æ”¶ç›Šæ˜¯å¿…è¢«å–è¿‡çš„ï¼Œæ‰€ä»¥å¦‚æœè·³åˆ°çš„ç‚¹æ˜¯å›åˆ°ç¬¬ä¸€å—äº†ï¼Œæ”¶ç›Šæ˜¯0ã€‚ å¦‚æœè·³åˆ°çš„ç‚¹ä¹Ÿæ˜¯åç‚¹ï¼Œæ”¶ç›Šæ˜¯0ã€‚ ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114/** solution for https://nanti.jisuanke.com/t/41402**///#include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;string.h&gt;#include &lt;tuple&gt;#define _debug(x) cerr&lt;&lt;#x&lt;&lt;\" = \"&lt;&lt;x&lt;&lt;endlusing namespace std;typedef long long ll;const int MAXN = 1e5 + 59;const int MAXM = 2e5 + 59;const ll MOD = 998244353;const ll INF = 0x0f0f0f0f;int fa[MAXN];int sz[MAXN];int findf(int x) { if (x == fa[x])return x; else { sz[fa[x]] += sz[x]; sz[x] = 0; return fa[x] = findf(fa[x]); }}void mergf(int x, int y) { int fx = findf(x); int fy = findf(y); if (fx == fy)return; if (sz[fx] &lt;= sz[fy]) { sz[fx] += sz[fy]; sz[fy] = 0; fa[fy] = fx; } else { sz[fy] += sz[fx]; sz[fx] = 0; fa[fx] = fy; }}int Kase;int n, m, k;pair&lt;int, int&gt; e[MAXM];int a[MAXN];bool tag[MAXN];bool vis[MAXN];vector&lt;int&gt; g[MAXN];int main() { ios_base::sync_with_stdio(false); cin.tie(nullptr); cin &gt;&gt; Kase; while (Kase--) { cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for (int i = 1; i &lt;= n; ++i) { fa[i] = i; sz[i] = 1; tag[i] = false; vis[i] = false; g[i].clear(); } for (int i = 1; i &lt;= m; ++i) { cin &gt;&gt; e[i].first &gt;&gt; e[i].second; } for (int i = 1; i &lt;= k; ++i) { cin &gt;&gt; a[i]; tag[a[i]] = true; sz[a[i]] = 0; } for (int i = 1; i &lt;= m; ++i) { if (tag[e[i].first] == 0 &amp;&amp; tag[e[i].second] == 0) { mergf(e[i].first, e[i].second); } } for (int u, v, i = 1; i &lt;= m; ++i) { tie(u, v) = e[i]; v = findf(v); u = findf(u); if (tag[u] || tag[v]) { g[u].emplace_back(v); g[v].emplace_back(u); } } int start = findf(1); double ans = sz[start]; double tmp = 0; for (auto u:g[start]) { if (vis[u])continue; else vis[u] = true; double sum = 0; for (auto v:g[u])if (v != start)sum += sz[v]; sum /= 1.0 * g[u].size(); if (sum &gt; tmp) tmp = sum; } ans += tmp; printf(\"%.6f\\n\", ans); } return 0;}","link":"/2019/09/16/CP/Solutions/jsk-41402-ICPC-Shenyang-Pre-E/"}],"tags":[{"name":"github","slug":"github","link":"/tags/github/"},{"name":"ç…§ç‰‡","slug":"ç…§ç‰‡","link":"/tags/ç…§ç‰‡/"},{"name":"å»ºç«™","slug":"å»ºç«™","link":"/tags/å»ºç«™/"},{"name":"çº¿æ®µæ ‘","slug":"çº¿æ®µæ ‘","link":"/tags/çº¿æ®µæ ‘/"},{"name":"hdu","slug":"hdu","link":"/tags/hdu/"},{"name":"å•è°ƒæ ˆ","slug":"å•è°ƒæ ˆ","link":"/tags/å•è°ƒæ ˆ/"},{"name":"å‰ç¼€å’Œ","slug":"å‰ç¼€å’Œ","link":"/tags/å‰ç¼€å’Œ/"},{"name":"ä¼˜å…ˆé˜Ÿåˆ—","slug":"ä¼˜å…ˆé˜Ÿåˆ—","link":"/tags/ä¼˜å…ˆé˜Ÿåˆ—/"},{"name":"dp","slug":"dp","link":"/tags/dp/"},{"name":"è´ªå¿ƒ","slug":"è´ªå¿ƒ","link":"/tags/è´ªå¿ƒ/"},{"name":"æƒ³æ³•","slug":"æƒ³æ³•","link":"/tags/æƒ³æ³•/"},{"name":"æš´åŠ›","slug":"æš´åŠ›","link":"/tags/æš´åŠ›/"},{"name":"æ¦‚ç‡","slug":"æ¦‚ç‡","link":"/tags/æ¦‚ç‡/"},{"name":"å›¾è®º","slug":"å›¾è®º","link":"/tags/å›¾è®º/"}],"categories":[{"name":"Misc","slug":"Misc","link":"/categories/Misc/"},{"name":"c++","slug":"c","link":"/categories/c/"},{"name":"CP","slug":"CP","link":"/categories/CP/"},{"name":"Graph","slug":"CP/Graph","link":"/categories/CP/Graph/"},{"name":"Logs","slug":"CP/Logs","link":"/categories/CP/Logs/"},{"name":"Misc","slug":"CP/Misc","link":"/categories/CP/Misc/"},{"name":"Solutions","slug":"CP/Solutions","link":"/categories/CP/Solutions/"}]}